[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python book",
    "section": "",
    "text": "Preface\nStart your coding journey with Python Book! This book is ideal for beginners to learn to program. Python is a modern high-level programming language that has applications in diverse fields.\nTo learn more about Bioinformatics learning resources, please visit bioinfo.guru.\nFor any query or feedback related to Python Book, please reach out to the author at manish@bioinfo.guru",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Why learn programming?\nThis is a frequently asked question that is why I should learn a programming language. There are multiple merits of learning the basic framework of computer programs. First, learning a programming language helps us develop logical skills, that’s because programming requires breaking down a problem and approaching a solution in a logical manner. All the computer algorithms are based on the idea that – understand the problem, break it down into different steps, and then go about solving the problem step by step. In the modern world everything is based on computers and having an ability to communicate with computers (via programming language) would help us understand the basis of functioning of any computer program. We will be able to “sense” the workflow of a program and to draw a relationship between input(s) and output(s).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#why-learn-python",
    "href": "intro.html#why-learn-python",
    "title": "Introduction",
    "section": "Why learn Python?",
    "text": "Why learn Python?\nAnother frequently asked question is why should I learn Python programming Python is the modern programming language that is being actively developed. It offers all the features expected out of a high and programming language that too with a rather flat learning curve. The coding syntax is pretty much like writing in plain English so that it makes it easier for a novice to learn this programming language. This advantage is particularly applicable for researchers in the field of Biology because, conventionally, students of biology have little or no exposure to computer related subjects. So, to get them started with programming, Python is an ideal choice. There are of course other advantages as well, like Python is an object-oriented programming language. It is an interpreted language i.e. the code is executed line by line which helps a new coder to identify and debug errors somewhat easily. Most importantly, python offers plenty of libraries to add additional functionality specific to a particular domain. For example, libraries like NumPy and Matplotlib can be used for numerical analysis and data visualization, respectively. Active development and a large user community allows exchange of ideas and speed up troubleshooting tasks.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#im-a-biologist-why-should-i-learn-to-code",
    "href": "intro.html#im-a-biologist-why-should-i-learn-to-code",
    "title": "Introduction",
    "section": "I’m a biologist, why should I learn to code?",
    "text": "I’m a biologist, why should I learn to code?\nModern Biology research is highly data intensive. Platform technologies are generating data like never before; and to parse the data we need computers. To use computers innovatively and productively, knowledge of programming is a must. Further, there are several software available for bioinformatics research; understanding programming concepts would enable us to interface with these tools in a much better and efficient manner than otherwise. To be a skilled computational biologist we need to understand the workflow that connects – concepts to algorithms to coding. One need not be an expert in all these domains but must have a basic understanding of this workflow. Once you have a vision of the big picture and you are an expert in at least one of these components then you can always collaborate with other experts to do wonderful things together.\nIn Bioinformatics, particularly in the recent past, a lot of tools have been developed using python, e.g. one of the most popular structure visualization programs PyMol is developed using Python. Similarly, there are many other libraries that facilitate different kinds of analysis using biological data. Considering all these factors, the ability of code in python is an asset for biologists doing data intensive research.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1  Setup",
    "section": "",
    "text": "1.1 Python distributions\nThe first thing that you need to do is to install Python. There are various distributions available online one of the such option is to download from the python offical site. Anaconda is another popular python distribution. Once you have download the executable file the installation is straight forward process.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "setup.html#integrated-development-environments",
    "href": "setup.html#integrated-development-environments",
    "title": "1  Setup",
    "section": "1.2 Integrated Development Environments",
    "text": "1.2 Integrated Development Environments\nAfter python installation the next thing you need is a code editor. Although any text editor (such as Notepad++/vi/TextEdit) can serve this purpose but it is highly recommend to install atleat one IDE (Interactive Development Environment). The Anaconda distribution comes bundled with Jupyter (an IDE). VS Code (Visual Studio Code) is an other popular IDE among software deveplopers. The IDEs have several useful features such as syntax highlighting, code auto-completion, options to install plugin, etc. that elevate the coding experience. The figure below shows the interface for Jupyter and VS Code.\n\n\n\n\n\n\n\n\n\n\n\n(a) Jupyter\n\n\n\n\n\n\n\n\n\n\n\n(b) VS Code\n\n\n\n\n\n\n\nFigure 1.1: Integrated Development Environments (IDEs)\n\n\n\nIn addition to these IDEs, Google Collaboratory is an online Jupyter notebook that can be used to execute python code in the cloud.\nThroughout this book, the python code is shown as a code block with grey background, e.g.\n\nprint(\"Hello World!\")\n\n\n\n\n\n\n\nQuick tip\n\n\n\nWhen you hover the mouse pointer over a code cell, there will be an option on the right to copy the contents of that cell.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "setup.html#useful-links",
    "href": "setup.html#useful-links",
    "title": "1  Setup",
    "section": "1.3 Useful links",
    "text": "1.3 Useful links\n\n\n\nName\nWebsite\n\n\n\n\nPython website\nhttps://python.org\n\n\nAnaconda\nhttps://www.anaconda.com/products/individual\n\n\nGoogle Colab\nhttps://research.google.com/colaboratory/\n\n\nVS Code\nhttps://code.visualstudio.com/",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "Variables_Operators.html",
    "href": "Variables_Operators.html",
    "title": "2  Variables",
    "section": "",
    "text": "2.1 Operators\nIn programming variables refers to a “name” for a value. This “name” can have different values over the course of program and hence it is referred as a variable. The concept of variable in programming is similar to some of terms used in natural languages to refer to different things. For instance, in a classroom there are students with different names. Here the word name is a variable which has differnt value for each student i.e. their name.\nThe above statement initializes a variable named ‘a’ with a numeric value of 2 and it is refered to as an Assignment Statement. Similarly, the statement below initializes a variable with name ‘test’ and assigns a string (or a text) value of ‘Happy’\nWe can print the value of a variable using the print command i.e.\nThe value assigned to a variable can be changed within the program. This feautre make variable very useful and are extensively used in progamming. A variable, for example, can be used to store user input.\nEach variable in Python has 6 properties associated with it. For now only first three are required since the last three are for advanced programmers. These properties are 1. Name 2. Value 3. Type 4. Scope 5. Life time 6. Memory location\nThe first two properties i.e. name and value we have already seen above. Type for a variable refers to it’s data type i.e. whether the variable is an integer, float, string, boolean, etc.\nIn Python, the type for a variable is decided at the time of initialization. This behaviour is different from languages like C where the type of the variable has to be declared explicitly. In the example above, we can change the variable ‘a’ to a non numeric value. To check the type for a particular variable, type() function can be used as follows.\nVariable names are case sensitive, e.g. in the code below there are four different variables such that their name differ only in the case used for the letters.\nAn operator is a special symbol that instructs the compiler/interpreter to execute specific mathematical or logical operations. These symbols operate on set of variable or scaler or both. Operand refers to the value that operator operates on. E.g., in the equation 2+3 ‘+’ is an operator and 2 and 3 are operands.\nIn Python there are 6 different classes of operators. These are: 1. Arithmetic operators 2. Comparison operators 3. Logical operators 4. Assignment operators 5. Bitwise operators 6. Special operators\nLet’s understand each of these classes through some examples",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Operators.html#arithmetic-operators",
    "href": "Variables_Operators.html#arithmetic-operators",
    "title": "2  Variables",
    "section": "2.2 Arithmetic operators",
    "text": "2.2 Arithmetic operators\nAs the name suggests this class of operators are used to perform mathematical operation on the operands. Following is the list of arithemetic operators available in Python.\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n+\nAddition\n2 + 2 = 4\n\n\n-\nSubtraction\n5 - 2 = 3\n\n\n*\nMultiplication\n2 * 3 = 6\n\n\n/\nDivision\n4 / 2 = 2\n\n\n%\nModulus\n4 % 2 = 0\n\n\n//\nFloor division\n5 // 2 = 2\n\n\n**\nExponent\n2 ** 3 = 8\n\n\n\n\nx = 4\ny = 5\nprint (x+y+2)\nprint (x-y+2)\n\n11\n1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Operators.html#comparison-operator",
    "href": "Variables_Operators.html#comparison-operator",
    "title": "2  Variables",
    "section": "2.3 Comparison operator",
    "text": "2.3 Comparison operator\nThese operators are used to compare operands and the output from their operation is a boolean value i.e. either True or False or equivalently 1 or 0.\nFollowing is the list of arithemetic operators available in Python.\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n&gt;\nGreater than\n3 &gt; 2 is True\n\n\n&lt;\nLess than\n3 &lt; 2 is False\n\n\n==\nEqual to\n2 == 3 is False\n\n\n!=\nNot equal to\n2 != 3 is True\n\n\n&gt;=\nGreater than or equal to\n4 &gt;= 2 is True\n\n\n&lt;=\nLess than or equal to\n5 &lt;= 2 is False\n\n\n\n\nx = 4\ny = 5\nprint (x+y &gt; 10)\n\nFalse",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Operators.html#logical-operators",
    "href": "Variables_Operators.html#logical-operators",
    "title": "2  Variables",
    "section": "2.4 Logical operators",
    "text": "2.4 Logical operators\nThere are 3 logical operators and, or, and not.\n\n\n\nOperator Symbol\nMeaning\n\n\n\n\nand\nTrue if both operands are true\n\n\nor\nTrue if either of the operands is true\n\n\nnot\nTrue if operands are false\n\n\n\n\nx = True\ny = False\nprint (x and y)\nprint (x or y)\nprint (not x)\n\nFalse\nTrue\nFalse\n\n\n\nx=5\ny=6\nz=7\nprint (x&lt;y and y&lt;z)\n\nTrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Operators.html#assignment-operators",
    "href": "Variables_Operators.html#assignment-operators",
    "title": "2  Variables",
    "section": "2.5 Assignment operators",
    "text": "2.5 Assignment operators\nOperators in this class are used to assign values to variables. The syntax for using these operators is variable name followed by operator followed by the value that is to be assigned. Some of the assignment operator behave equivalent to the mathematical operation performed by arithmetic operators.\nFollowing is the list of assignment operators available in Python.\n\n\n\n\n\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n=\nAssign value on the right to variable on the left\nx = 5\n\n\n+=\nIncrement value of the variable by value on the right\nx += 5 (x = x + 5)\n\n\n-=\nDecrement value of the variable by value on the right\nx -= 5 (x = x - 5)\n\n\n*=\nMultiple value of the variable by value on the right\nx *= 5 (x = x * 5)\n\n\n/=\nDivide value of the variable by value on the right\nx /= 5 (x = x / 5)\n\n\n%=\nModulus for the value of the variable by value on the right\nx %= 5 (x = x % 5)\n\n\n//=\nFloor division of value of the variable by value on the right\nx //= 5 (x = x // 5)\n\n\n**=\nExponent value of the variable by value on the right\nx **= 5 (x = x ** 5)\n\n\n\n\nQuiz: What would be the output of the following code  x = 6  x **= 2  print(x)\n\n\n\nShow answer\n36\n\n\n\nQuiz: What would be the output of the following code  x = False  print(type(x))\n\n\n\nShow answer\nx = False\nprint(type(x))\n\n#output \n#&lt;class 'bool'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Strings.html",
    "href": "Strings.html",
    "title": "3  Strings",
    "section": "",
    "text": "3.1 String concatenation\nIn programming string refers to a sequence of characters that can act as a variable or constant. This is the most popular data type in Python. In fact the increasingly strong prevelance of Python in Bioinformatics is primarily due to its ability to easily perform different operations of strings. A string variable can be assigned a value using either single or double quotes.\nTo check the data type of a variable, we can use the type function. The get number of character in a string variable use the len function. Note that a blank space is also considered as a character.\nThe process of joining two or more things is called as concatenation. The arithmetic operators + and * can be used directly with strings to concatenate (addition) or repeat (multiplication). This process of giving additional functions to operator (beyond their existing functions) is called as operator overloading. E.g. the plus (+) operator is used for addition given that the operands are integers. However, if the operands are string then it act as a concatenation operator instead of addition operator.\n# The plus (+) operator with two numbers\n2+3\n\n5\nvar1 = \"Hello\"\nvar2 = \"World!\"\nprint (var1+var2)\n\nHelloWorld!\nIn the case of asteriks (*) operator, which is used to multiple two numbers, when the operands are a string (s) and a number (n) the output is s repeated n times. This behaviour is similar to muliplication of two numbers. For instance, let say we want to multiple 5 by 3 (5*3). This multiplication can also be represented as sum of 5 three times i.e. 5+5+5. So, when we use a string (s) and a number (n) as operands for * operator we get s+s+s…(n times).\nvar3 = var1*3\nprint(var3)\n\nHelloHelloHello",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#slice-of-a-string",
    "href": "Strings.html#slice-of-a-string",
    "title": "3  Strings",
    "section": "3.2 Slice of a string",
    "text": "3.2 Slice of a string\nSlice is another very useful operator that can be used to manipulate strings. The slice operator [] gives the character within the start and end positions separated by a colon. The numbering of characters within a string start from 0. Note that the start position character is included in the output but the end position character is not. Slicing effectively return the substring of a given string. The general syntax for slicing a string is as follows:\nstring[start:end] string[start:] string[:end] string[start:end:step]\nLet’s see some examples to get a better understanding to the slice operation.\n\nvar4 = \"ABCDEFG\"\nprint(var4)\nprint(var4[1:5])\n\nABCDEFG\nBCDE\n\n\nIn case no value is specified before or after the colon then the slicing would occur from begining or till end respectively.\n\nprint(var3)\nprint(var3[:7])\nprint(var3[3:])\n\nHelloHelloHello\nHelloHe\nloHelloHello\n\n\nThe step part in the slice operator specific the number of steps to take when going from the start position to the end position. The default step size is 1. We can change the default value by specifying the step parameter within the slice command.\n\nprint(var3)\nprint(var3[2::2])\n\nHelloHelloHello\nloelHlo\n\n\n\nQuiz: Write a command that outputs ‘HHH’ given a string ‘HelloHelloHello’.\n\n\n\nShow answer\nvar3 = \"HelloHelloHello\"\nprint(var3[::5])",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#string-comparison",
    "href": "Strings.html#string-comparison",
    "title": "3  Strings",
    "section": "3.3 String comparison",
    "text": "3.3 String comparison\nOne of the frequently required tasks in programming is string comparison. In Python comparison operator can be used to compare two strings. The == (two equal symbols without space) is the comparison operator. The output of comparison is a boolean value i.e. either True or False. String comparison is case sensitive.\n\nvar1 = 'Hello'\nvar2 = \"Hello\"\nvar3 = 'Hi'\nprint(var1 == var2)\nprint(var1 == var3)\nprint(var1 == \"hello\")\n\nTrue\nFalse\nFalse",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#splitting-string",
    "href": "Strings.html#splitting-string",
    "title": "3  Strings",
    "section": "3.4 Splitting string",
    "text": "3.4 Splitting string\nSometimes there is a need to split a string based on certain delimiters, the split function is designed for that task. Python String types have split function associated with them that return a list of elements after splitting the string as per the delimiter. The default delimiter is blank space.\n\ns1 = \"This is a sentence.\"\nwords1 = s1.split()\nprint(words1)\n\n#split with comma as a delimiter\ns2 = 'This is an another sentence, a longer one.'\nwords2 = s2.split(\",\")\nprint(words2)\n\n['This', 'is', 'a', 'sentence.']\n['This is an another sentence', ' a longer one.']\n\n\n\nQuiz: What would be the output if we split s2 using “is” as a delimiter.\n\n\n\nShow answer\ns2 = 'This is an another sentence, a longer one.'\nprint(s2.split(\"is\"))\n\n##Output would be a list with three elements:\n##['Th', ' ', ' an another sentence, a longer one.']",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#string-functions",
    "href": "Strings.html#string-functions",
    "title": "3  Strings",
    "section": "3.5 String functions",
    "text": "3.5 String functions\nPython strings have several methods to work with string objects. Below are examples of some of the functions available is class ‘str’. These methods acts on the string and returns a new string after doing the required manipulations. For additional functions, please refer to the python documentation.\n\n\ns1 = \"Apple\"\n\nString function           Output\n————————————————————————————————\ns1.upper()                APPLE\ns1.lower()                apple\ns1.startswith(\"a\")        False\ns1.startswith(\"A\")        True\ns1.index(\"l\")             3\ns1.replace(\"e\",\"es\")      Apples",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#doc-strings",
    "href": "Strings.html#doc-strings",
    "title": "3  Strings",
    "section": "3.6 Doc strings",
    "text": "3.6 Doc strings\nTo declare a variable whose value is a long string that spans multiple lines tripple quotes can be used. All white spaces such as tabs and newline are considered part of the string. These types of strings are generally used for documentation purposes e.g. writing help text for custom functions.\n\nvar4 = \"\"\"This is an example of\na long string that spans \nthree lines.\"\"\"\nprint (var4)\n\nThis is an example of\na long string that spans \nthree lines.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Strings.html#strings-key-characteristics",
    "href": "Strings.html#strings-key-characteristics",
    "title": "3  Strings",
    "section": "3.7 Strings – key characteristics",
    "text": "3.7 Strings – key characteristics\n\nA string variable stores text data\n\nA string variable can store characters including white spaces (space, tab, newline). A string variable is an object of class ‘str’. To initialize a string variable, single or double quotes can be used.\n\nA string variable is immutable\n\nIn Python the strings are immutable i.e. their value cannot be changed once it has been assigned. The values can however be reassigned. The value of a string variable can change but the data contained within a variable can`t be changed.\n\nA strings variable is a list\n\nA string variable is a also a list i.e. a collection of characters. We can iterate through characters in a string just like we can iterate through any list. Unlike lists, however, characters cannot be appended to a string because strings are a immutable data type.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Numbers.html",
    "href": "Numbers.html",
    "title": "4  Numbers",
    "section": "",
    "text": "4.1 Formatted print\nPython has a couple of different options for data types when it comes to working with numbers. Numbers without and with demical points are refered to as int (integers) and float (floating point). So, depending upon how we initialize a variable, its data type would be assigned accordingly. Both these data types can have negative values. The int and float functions can be used to explicity assign the corresponding data types. Note, when assigning and int data type to a number with decimal value, only the interger part is retained. For working with complex numbers there is an additional data type complex.\nA numeric variable can also be initiatlized using scientific notation i.e. e notation. The e can be both lower or upper case. Variables declared with a scientific notation are always float.\nThe data type for the output of an arithmetic operator would depend on the data type of the operands. If both the operands are int then the output would also be int. An exception to this is / (division) where the data type for the output is always float irrespective of the data type of the operands. Also, if at least one of the operand is float then the data type for the output would be float.\nTo print a floating point number with a desired number of decimal places we can use the formatted print option. The %f format specifier can be used to indicate the required number of decimal places for the output. Here, we also have an option to include the sign (+) in case of positive number. In addition to this, the round function can also be used which takes two arguments – the floating point number and the required number of decimal places.\nn = 1234.5678\n\nFormatted print           Output\n————————————————————————————————\nprint(\"%.2f\" % n)         1234.57\nprint(\"%+.2f\" % n)        +1234.57\nprint(\"%.2e\" % n)         1.23e+03\nprint(\"%.d\" % n)          1234",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "Numbers.html#f-strings",
    "href": "Numbers.html#f-strings",
    "title": "4  Numbers",
    "section": "4.2 f-strings",
    "text": "4.2 f-strings\nFrom python 3.6 onwards, formatting of variable, calculations of mathematical expression etc. can be easily done within the print statement. These string starts with f. The variables inside the f-strings are enclosed within curly braces {}. The formatting is similar to as we described above, the code is relatively cleaner and easy to follow.\n\na = -4\nb = 5.0\nprint(f'The product of {a} and {b} is {a*b}')\nprint(f'The product of {a} and {b} is {a*b:0.3f}')\n\nThe product of -4 and 5.0 is -20.0\nThe product of -4 and 5.0 is -20.000",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "Numbers.html#complex-numbers",
    "href": "Numbers.html#complex-numbers",
    "title": "4  Numbers",
    "section": "4.3 Complex numbers",
    "text": "4.3 Complex numbers\nComplex numbers can be initialized using the complex function which takes either one or two arguments, depending upon the nature of argument: - a complex number is specified directly - the real and imaginary parts are specified as separate arguments.\n\nc = complex(3+6j)\nz = complex(5,2)\nprint(c, z)\nprint(f\"The real component of z is {z.real}\")\nprint(f\"The imaginary component of z is {z.imag}\")\nprint(f\"The conjugate of z is {z.conjugate()}\")\n\n(3+6j) (5+2j)\nThe real component of z is 5.0\nThe imaginary component of z is 2.0\nThe conjugate of z is (5-2j)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "Lists.html",
    "href": "Lists.html",
    "title": "5  Lists",
    "section": "",
    "text": "5.1 Modifing contents of a list\nA collection of items, in python, is refered to as a list. A list can have elements of same data type or multiple data types. A list is denoted by square brackets ([]). The indexing of elements in a list starts from zero. To access an element by its index we can specify index in square brackets after the list name. Slicing of lists can be performed as well.\nA list is a mutable data type i.e. the contents of the collection can be changed. The append and extend functions adds an element or a collection of elements to a list. To add an element at a specified position within the list, the insert function can be used.\nfruits.append(\"mango\")\nprint(fruits)\nprint(len(fruits))\n\n['apple', 'banana', 'mango']\n3\nfruits = [\"apple\", \"banana\"]\nfruits2 = [\"pineapple\",\"cherry\"]\nfruits.append(fruits2) #adding a list using append\nprint(fruits)\nprint(len(fruits))\n\nfruits = [\"apple\", \"banana\"]\nfruits2 = [\"pineapple\",\"cherry\"]\nfruits.extend(fruits2) #adding a list using extend\nprint(fruits)\nprint(len(fruits))\n\n['apple', 'banana', ['pineapple', 'cherry']]\n3\n['apple', 'banana', 'pineapple', 'cherry']\n4\nfruits.insert(1,\"grapes\")\nprint(fruits)\n\n['apple', 'grapes', 'banana', 'pineapple', 'cherry']\n# slicing\nprint(fruits[1:4])\n\n['grapes', 'banana', 'pineapple']\nTo remove the last element from a list, pop function can be used. By default, it returns a the last element and the original list is shortened by one element. The optional positional argument to specify the index of the element that is to be “popped”.\nlast_fruit = fruits.pop()\nprint(fruits)\nprint(last_fruit)\n\n['apple', 'banana', 'pineapple']\ncherry\nfruits = ['apple', 'banana', 'pineapple', 'cherry']\npopped_fruit = fruits.pop(2) # pop the element at index 2.\nprint(popped_fruit)\nprint(fruits)\n\npineapple\n['apple', 'banana', 'cherry']\nTo remove an element by its name use the remove function. Note that if a list has duplicate elements then the remove function will delete only the first occurance of that element.\nfruits.remove(\"banana\")\nprint(fruits)\n\n['apple', 'pineapple']",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "Lists.html#list-functions",
    "href": "Lists.html#list-functions",
    "title": "5  Lists",
    "section": "5.2 List functions",
    "text": "5.2 List functions\nThere are some useful functions available to manupulate lists. These functions act in place i.e. these functions do not return anything and just modifies the original list.\n\nfruits = ['apple', 'banana', 'mango', 'pineapple', 'cherry', 'banana']\nprint(fruits.count(\"banana\"))\nfruits.reverse()\nprint(fruits)\nfruits.sort()\nprint(fruits)\nfruits.sort(reverse=True)\nprint(fruits)\n\n2\n['banana', 'cherry', 'pineapple', 'mango', 'banana', 'apple']\n['apple', 'banana', 'banana', 'cherry', 'mango', 'pineapple']\n['pineapple', 'mango', 'cherry', 'banana', 'banana', 'apple']\n\n\n\nQuiz: Given a list nums=[1,2,3,4,5]. Write a code to print 4.\n\n\n\nShow answer\nnums = [1,2,3,4,5]\nprint(nums[3])",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html",
    "href": "Conditional_statements.html",
    "title": "6  Conditional Statements",
    "section": "",
    "text": "6.1 if and else statements\nMany a times in the life cycle of a program there are instances when you would like to run a certain code based on whether a particular condition is met or not. A real-world example of this would be screening of content based on the user’s age. If, e.g., the user is 18+ then all the content is accessible to the user while if the user is below 18 then certain content is restricted. These kind of testing of condition(s) and then executing the specific code accordingly is facilitated by the conditional statements.\nTo test a particular condition, if statement is used with some condition that we need to check. This kind of checking generally involves a comparison operator such that the output is always Boolean (true/false). In case the output of the comparison is true the code block following the if statement gets executed. On the other hand, if the condition is false then the code specified under the else block gets executed. Note that there is no testing of condition in case of else statement since the else directly means when the if condition is false.\nWhen using conditional statements, there are two syntactical points that you need to keep in mind:\nflowchart TD\n      A[Input first number x] --&gt; B[Input second number y]\n  B --&gt; C{Is x &gt; y?}\n  C --&gt; |Yes| D[x is greater than y]\n  C --&gt; |No| E[x is less than y]\n\n\nFlowchart to find greater of the two numbers.\nx = 5\ny = 6\n\nif(x&gt;y):\n    print(\"X is greater than Y\")\nelse:\n    print(\"X is less than Y\")\n\nX is less than Y",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#if-and-else-statements",
    "href": "Conditional_statements.html#if-and-else-statements",
    "title": "6  Conditional Statements",
    "section": "",
    "text": "The if and the else statements ends with a colon (:).\nThe code blocks corresponding to if and else have to be indented (i.e. leading spaces at the begining of the line).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#elif",
    "href": "Conditional_statements.html#elif",
    "title": "6  Conditional Statements",
    "section": "6.2 elif",
    "text": "6.2 elif\nMultiple conditions can be tested as well the elif keyword. The syntax for this keyword is similar to the if keyword i.e. elif also takes a condition within parenthesis. The else keyword take no argument such that its code block gets executed when the if condition (and elif) conditions are return False.\n\n\n\n\nflowchart TD\n  A[\"Input first number x\"] --&gt; B[Input second number y]\n  B --&gt; C{Is x &gt; y?}\n  C --&gt; |Yes| D[x is greater than y]\n  C --&gt; |No| E{Is x less than y?}\n  E --&gt; |Yes| F[x is less than y]\n  E --&gt; |No| G[x is equal to y]\n\n\nFlowchart to compare two numbers.\n\n\n\n\nif(x&gt;y):\n    print(\"X is greater than Y\")\nelif(x&lt;y):\n    print(\"X is less than Y\")\nelse:\n    print(\"X is equal to Y\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#nested-conditional-statements",
    "href": "Conditional_statements.html#nested-conditional-statements",
    "title": "6  Conditional Statements",
    "section": "6.3 Nested conditional statements",
    "text": "6.3 Nested conditional statements\nFor situations when there is a need to check multiple conditions in tandem, we can have nested conditional statements. This is different from the elif statement since here we need to check certain condition after some condition has already been tested to be true (or false depending upon the code). For instance, let’s say, we want to write a program that checks whether a number is even or odd and, if even, check whether the number ends with a zero.\n\n\n\n\n%%{init: {'theme':'neutral'}}%%\ngraph TD\n  A[Input a number x] --&gt; B{Is x even?}\n  B --&gt; |Yes| C{Does x ends \\n with a zero?}\n  B --&gt; |No| D[x is odd]\n  C --&gt; |Yes| E[x is even and ends with a zero.]\n  C --&gt; |No| F[x is even and does not ends with a zero.]\n\n\nFlowchart for nested conditions.\n\n\n\n\nx = 50\nif(x % 2 == 0):\n    if (x % 10 == 0):\n        print(\"The number is even and ends with a zero.\")\n    else:\n        print(\"The number is even and does not ends with a zero.\")\nelse:\n    print(\"The number is odd.\")\n\nThe number is even and ends with a zero.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#conditionals-with-boolean-operators",
    "href": "Conditional_statements.html#conditionals-with-boolean-operators",
    "title": "6  Conditional Statements",
    "section": "6.4 Conditionals with Boolean operators",
    "text": "6.4 Conditionals with Boolean operators\nThere are situations when multiple conditions need to be tested simultaneously. For such cases, we can use the Boolean operators – and, or, and not – with the if statement. To understand this let’s write a code to test, given two numbers, which number is greater and is the difference between the two numbers greater than 10.\n\n\n\n\n%%{init: {'theme':'neutral'}}%%\nflowchart TD\n  A[\"Input first number x\"] --&gt; B[Input second number y]\n  B --&gt; C{Is x &gt; y? \\n Is their difference \\n greater than 10?}\n  C --&gt; |Yes| D[x is greater than y \\n and \\n their difference is greater than 10.]\n  C --&gt; |No| E[Either x is less than y \\n or \\n their difference is less than 10.]\n\n\nFlowchart for comparison with Boolean logic.\n\n\n\n\nx = 20\ny = 5\n\nif((x &gt; y) and (x-y &gt; 10)):\n    print(\"x is greater than y and the difference in x and y is more than 10.\")\nelse:\n    print(\"Either x is less than y or the difference in x and y is less than 10 or both.\")\n\nx is greater than y and the difference in x and y is more than 10.\n\n\n\nQuiz: Write a program to check if a number is completely divisible by five.\n\n\n\nShow answer\nx = 15\nif(x % 5 == 0):\n    print(\"The number is completely divisible by five\")\nelse:\n    print(\"The number is not completely divisible by five\")\n\n\n\nQuiz: Given a date of birth, write a program to check in which quater of the year the person was born.\n\n\n\nShow answer\n# Note that the date of birth should be in a specific format e.g. DD/MM/YYYY.\nDOB = \"14/02/2000\"\nmonth = int(DOB.split(\"/\")[1]) #change to integer data type.\nif(month &lt; 4):\n    print(\"The person was born in the first quater\")\nelif(month &gt; 3 and month &lt; 7):\n    print(\"The person was born in the second quater\")\nelif(month &gt; 6 and month &lt; 10):\n    print(\"The person was born in the third quater\")\nelse:\n    print(\"The person was born in the fourth quater\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#using-in-with-conditionals",
    "href": "Conditional_statements.html#using-in-with-conditionals",
    "title": "6  Conditional Statements",
    "section": "6.5 Using in with conditionals",
    "text": "6.5 Using in with conditionals\nSo far we have seen the use of conditional operators for framing the if statements. When working with lists (or for that matter strings) we can use the in keyword to check for the presence of a particular element (or character).\n\nfruits = [\"Apple\", \"Mango\", \"Banana\"]\nif(\"Mango\" in fruits):\n    print(\"Make a mango shake\")\nelse:\n    print(\"No mango shake\")\n\nMake a mango shake\n\n\n\nx = \"abcde\"\nif(\"c\" in x):\n    print(\"c is there\")\nelse:\n    print(\"c is not there\")\n\nc is there",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Conditional_statements.html#functions-that-return-a-boolean-value",
    "href": "Conditional_statements.html#functions-that-return-a-boolean-value",
    "title": "6  Conditional Statements",
    "section": "6.6 Functions that return a Boolean value",
    "text": "6.6 Functions that return a Boolean value\nWe can also construct the conditional statements using functions that return a Boolean value.\n\nx = \"Apple\"\nif(x.startswith(\"A\")):\n    print(\"The first alphabet of the variable x is A\")\nelse:\n    print(\"The first alphabet of the variable x is not A\")\n\nThe first alphabet of the variable x is A\n\n\n\n# The isinstance function checks if an object is an instance of a given class.\n\ny = 5.0\nif(isinstance(y, int)): \n    print(\"y is an integer\")\nelse:\n    print(\"y is not an integer\")\n\ny is not an integer",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "Loops.html",
    "href": "Loops.html",
    "title": "7  Loops",
    "section": "",
    "text": "7.1 For loop\nIn programming often times there is a requirement that a particular set of instructions is required to be repeated certain number of times. This can be easily achieved using loops. These statements execute a code block repeatedly for specified number of times or until a condition is met.\nThe most common loop that is used to repeat a block of code for fixed number of times is for loop. The example below show iterating through all the elements of a list. Syntactically, the for code block is similar to the if block in terms of the use of colon and indentation.\nlist_of_numbers = [1, 2, 3, 4, 5] \nfor x in list_of_numbers:\n    print(x*2)\nprint(\"Done\")\n\n2\n4\n6\n8\n10\nDone\nThe for statement begins with the for keyword which is followed by a variable name (x in the example above). This variable would store the different elements in the list as the loop progressess. The in keyword connects the variable with the list and finally we have the list that we want to iterate. The colon (:) at the end is required. It indicates the begining of the block of statements that would be part of the for loop. Next, we have a set of statement that needs to executed for each element of the list. The statement that are part of the for loop must begin with indentation (tab or some spaces). In the example above, the print(x*2) statement is part of the for loop (since it is indented) while the print(\"Done\") statement is not part of the for loop since it is not indented. There must be atleast one statement which is part of the for loop (i.e. atleast one statement that starts with indentation).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Loops.html#keeping-track-of-indices-during-iteration",
    "href": "Loops.html#keeping-track-of-indices-during-iteration",
    "title": "7  Loops",
    "section": "7.2 Keeping track of indices during iteration",
    "text": "7.2 Keeping track of indices during iteration\nIn the code above, we were able to iterate through the items in a list using a for loop and perform some action on each of those items. However, there was no option to keep track of the index of an item during iteration. For cases where we need a list of items along with their indices, we have a couple of ways to achieve that. One way is to iterate through the range of numbers till the length of the list such the variable in the for loop will have the index of the items and the items themselves can be accessed by indexing the list, as shown below.\n\nnums = [10,20,30,40,50]\nfor x in range(len(nums)):\n    print(x, nums[x]) # use x+1 to start from 1 instead.\n\n0 10\n1 20\n2 30\n3 40\n4 50\n\n\nAnother way is to use the enumerate function with a list as an argument. This function returns an enumerate object having a collection of tuples – each of which has the index and the corresponding item in the list. When using this in a for loop, we need to provide two variables to store the two values from the tuple.\n\nnums = [10,20,30,40,50]\nfor x,y in enumerate(nums):\n    print(x,y)\n\n0 10\n1 20\n2 30\n3 40\n4 50\n\n\nThe default indexing for the enumerate function start with zero; which can be changed using the start keyword argument.\n\nnums = range(10,51,10)\nfor x,y in enumerate(nums, start=1):\n    print(x,y)\n\n1 10\n2 20\n3 30\n4 40\n5 50",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Loops.html#iterating-through-multiple-lists-simultaneously",
    "href": "Loops.html#iterating-through-multiple-lists-simultaneously",
    "title": "7  Loops",
    "section": "7.3 Iterating through multiple lists simultaneously",
    "text": "7.3 Iterating through multiple lists simultaneously\nThe zip function comes handy when the objective is to iterate through multiple lists (or other iterable python objects) at the same time. It returns a collection of tuples such that the nth tuple in this collection has nth element from all the lists passed as an argument. If the lists (which are passed as an argument to zip) are of unequal length then the iteration continues till the length of the shortest list. When running a for loop with zip, the number of variable should be equal to the number of lists passed to zip such that each items gets assigned to a different variable. A single variable can also be used in the for loop, in that case, that variable would be a tuple having the corresponding items.\n\nfruits = [\"Apple\", \"Banana\", \"Banana\"]\ndesserts = [\"pie\", \"pie\", \"shake\"]\nfor x,y in zip(fruits, desserts):\n    print(x,y)\n\nApple pie\nBanana pie\nBanana shake\n\n\n\nfor x in zip(range(10,51,10),\"abcde\"):\n    print(x[0],x[1])\n\n10 a\n20 b\n30 c\n40 d\n50 e\n\n\n\nQuiz: Write a program that takes a list of 10 numbers as input and prints the cube of each of the number in the list.\n\n\n\nShow answer\nx = range(1,11)\nfor y in x:\n    print(y**3)\n\n\nWe can also check multiple conditions at the same time. For this the Boolean operators (and, or, and not) are used along with the different conditions.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Loops.html#list-comprehension",
    "href": "Loops.html#list-comprehension",
    "title": "7  Loops",
    "section": "7.4 List comprehension",
    "text": "7.4 List comprehension\nWhen we need to perform one or two operations on all the elements of a list, we have an option to write the for loop in one line. This is referred as list comprehension.\n\nnums = range(1,6)\nfor x in nums:\n    print(x**2)\n\n# Using list comprehension\nnums_squared = [x**2 for x in nums]\nprint(nums_squared)\n\n1\n4\n9\n16\n25\n[1, 4, 9, 16, 25]\n\n\nWe can also have conditional statements when using list comprehension.\n\nnums = range(1,6)\nnum_even_square = [x**2 for x in nums if x%2==0]\nnum_even_square_odd_cube = [x**2 if x%2==0 else x**3 for x in nums]\nprint(num_even_square)\nprint(num_even_square_odd_cube)\n\n[4, 16]\n[1, 4, 27, 16, 125]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Loops.html#while-loop",
    "href": "Loops.html#while-loop",
    "title": "7  Loops",
    "section": "7.5 While loop",
    "text": "7.5 While loop\nWhile loop is another frequently used construct to perform task repeatedly when the number of iterations is not fixed. This loop is executed till certain condition is met irrespective of number of iterations.\nWhile expression:\n    code block\nWhile loop implicitly has a if conditional statement.\n\nx = 5\nwhile(x&gt;2):\n    print(x)\n    x = x-1\nprint(\"Loop is over\")\n\n5\n4\n3\nLoop is over\n\n\nWhen writting a while loop you must ensure that the condition is met at some point within the loop otherwise the loop will iterate infinitely. E.g. in the above code if the condition within while loop is changed to x&gt;2 then it result in an infinite loop.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Loops.html#controlling-the-execution-of-loops",
    "href": "Loops.html#controlling-the-execution-of-loops",
    "title": "7  Loops",
    "section": "7.6 Controlling the execution of loops",
    "text": "7.6 Controlling the execution of loops\nMany a times it is require to skip the execution of loop for certain steps or to terminate the loop altogether. Python has some reserved keyword to facilitate this task. continue can be used to jump to subsequent iteration of the loop and break can be used to end the loop. These special keywords are generally used in conjuction with conditional statements to manipulate the execution of the loops.\n\nfor x in range (1,10):\n    if (x == 5):\n        continue\n    print(x)\nprint(\"Done\")\n\n1\n2\n3\n4\n6\n7\n8\n9\nDone\n\n\n\nfor x in range (1,10):\n    if (x == 5):\n        break\n    print(x)\nprint(\"Done\")\n\n1\n2\n3\n4\nDone\n\n\n\nQuiz: Take a list of first 10 numbers and print the square for even numbers.\n\n\n\nShow answer\nfor x in range(1,11):\n    if(x%2 == 0):\n        print(x**2)\n    else:\n        continue",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Tuples.html",
    "href": "Tuples.html",
    "title": "8  Tuples and Sets",
    "section": "",
    "text": "8.1 Tuples - the immutable collection\nPython has different data types to store a collection of items. Tuples and sets are two such data types. Both these data have some unique characteristics that make them useful under different contexts.\nA tuple is a collection of items just like a list; with one important difference that this collection is immutable. In other words, there is no option to add or remove elements form a tuple. A tuple can have elements of same data type or multiple data types. A tuple is denoted by parantheses (()). A tuple can be initialized by putting a comma-separated collection of element within parantheses (or even with paranthesis). The tuple keyword can be used to convert a list to a tuple. Note that when initializing a tuple with single element we need to put a comma after the element. To access an element by its index we can specify index in square brackets after the tuple name. A slice of a tuple returns a tuple.\nfruits = (\"apple\", \"banana\", \"mango\")\nprint(fruits)\nprint(type(fruits))\nprint(fruits[1])\n\n('apple', 'banana', 'mango')\n&lt;class 'tuple'&gt;\nbanana\nfruits2 = \"pineapple\", \"cherry\"\nprint(fruits2)\n\n('pineapple', 'cherry')\nnums = [1,2,3,4,5]\nnums_tuple = tuple(nums)\nprint(nums_tuple)\n\n(1, 2, 3, 4, 5)\nTuple can be concatenated in the same manner as strings are concatenated. The + and * operators can be used for tuple concatenation.\nprint(fruits+fruits2)\nprint(fruits2*3)\n\n('apple', 'banana', 'mango', 'pineapple', 'cherry')\n('pineapple', 'cherry', 'pineapple', 'cherry', 'pineapple', 'cherry')\nQuiz: What would be the output of the following code.  fruits = (“apple”, “mango”)   fruits.append(“grapes”)    \n  print(fruits)\nShow answer\nError. Tuples are immutable.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tuples and Sets</span>"
    ]
  },
  {
    "objectID": "Tuples.html#tuples---the-immutable-collection",
    "href": "Tuples.html#tuples---the-immutable-collection",
    "title": "8  Tuples and Sets",
    "section": "",
    "text": "8.1.1 Advantages of Tuples\nThe fact that tuples are immutable is an important utility feature for this collection data type. For instance, the keys of a dictionary must be of immutable data type, so we can use tuples to have a collection of items as a key.\n\n# a dictionary with keys having studnets name and roll number and \n# values having the subjects taken.\nstudents_data = {('Sam', 102): ['Physics', 'Maths', 'Chemistry'],\n         ('Mohan', 103): ['Physics', 'Chemistry', 'Biology']}\nfor k1, v1 in students_data.items():\n    print(f'{k1[0]} (Roll No.{k1[1]}) has taken {\", \".join(v1)}.')\n\nSam (Roll No.102) has taken Physics, Maths, Chemistry.\nMohan (Roll No.103) has taken Physics, Chemistry, Biology.\n\n\nAn important point to note here is that when the tuples are used as a dictionary key then all the elements of a tuple should be immutable. If a tuple with an mutable element (e.g. a list) is used as a dictionary key then it would lead to a TypeError.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tuples and Sets</span>"
    ]
  },
  {
    "objectID": "Tuples.html#sets-and-their-characteristics",
    "href": "Tuples.html#sets-and-their-characteristics",
    "title": "8  Tuples and Sets",
    "section": "8.2 Sets and their characteristics",
    "text": "8.2 Sets and their characteristics\nA set is an another data type, just like lists and tuples, that can be used to store a collection of items. A set object can be initialized using the set function or using curly braces {} with elements inside. Note that using empty curly braces would initialize a dict object. The set function take a list as an argument for initializing a set. A notable difference between sets and other collections is that in sets the items are unordered. This implies that we cannot access individual elements of a set by their indices.\nFollowing are characteristics of sets: - Elements in a set are unordered and duplicate elements are not allowed. - Elements in a set must be of immutable data types only. - Elements can be added to and removed from a set.\n\na = {\"apple\", \"banana\", \"mango\"}\nprint(type(a))\nfor element in a:\n    print(element)\n\n&lt;class 'set'&gt;\nbanana\nmango\napple\n\n\nThe add and update functions can be used to add one or multiple elements to a set, respectively. To remove an element from a set, discard or remove functions can be used with element as an argument. The former would leave the set unchanged if an element is not present in that set, while the later would lead to an error.\n\na.add(\"cherry\")\nprint(a)\na.remove(\"cherry\")\nprint(a)\n\n{'banana', 'mango', 'apple', 'cherry'}\n{'banana', 'mango', 'apple'}\n\n\n\n8.2.1 Set operations\nWe can apply different logical operations to parse content of multiple sets. For instance, to get all the elements present in one set and not present in another set, we can use the minus - operator. Similarly, we can get the union and intersection of two sets using the | and & operators respectively. The carrot (^) operator return the unique elements in the two sets.\n\na = {\"apple\", \"banana\", \"mango\"}\nb = {\"apple\", \"banana\", \"cherry\"}\nprint(a,b)\nprint(\"Elements present in a and not in b\", a-b)\nprint(\"Elements present in b and not in a\", b-a)\nprint(\"Union of sets a and b\", a|b)\nprint(\"Intersection of sets a and b\", a&b)\nprint(\"Unique elements in sets a and b\", a^b)\n\n{'banana', 'mango', 'apple'} {'banana', 'apple', 'cherry'}\nElements present in a and not in b {'mango'}\nElements present in b and not in a {'cherry'}\nUnion of sets a and b {'banana', 'mango', 'apple', 'cherry'}\nIntersection of sets a and b {'banana', 'apple'}\nUnique elements in sets a and b {'mango', 'cherry'}\n\n\n Quiz: Which of the following expression is equivalent to a^b.  a-b&a+b  a-b|b-a a|b-a&b a&b-a|b \n\n\nShow answer\na-b|b-a",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Tuples and Sets</span>"
    ]
  },
  {
    "objectID": "Dictionaries.html",
    "href": "Dictionaries.html",
    "title": "9  Dictionaries",
    "section": "",
    "text": "9.1 Iterating through dictionaries\nThese are collection of items arranged as a key-value pair. A dictionary is represented by {} and there is a dict keyword in python to assign dictionary data type. The value for a particular key in a dictionary can be accessed by specifing the key within [] after the dictionary name.\nAn alternate way to initialize a dictionary is by using the dict keyword. In the code below, notice the differences in how the key-value pairs are specified while inititalize a dictionary with the dict keyword. The len function with a dictionary as an argument returns the total number of key-value pairs in that dictionary.\nThe values in a dictionary could any data type such as string, integer, list or even dictionary. On the other hand, keys can only be immutable data types such as string, integer or tuple.\nThe keys and values functions can be used to get all keys and all values as a list, respectively. To get all the keys of a dictionary as list, the list function with dictionary as an argument can also be used.\nprint(stationery.keys())\nprint(stationery.values())\nprint(list(stationery))\n\ndict_keys(['pens', 'paper'])\ndict_values([['ball', 'fountain'], ['A4', 'A3', 'A2']])\n['pens', 'paper']\nThe items function comes handy for iterating through the content of the dictionary. This function return the key-value pairs as a tuple and all these key-value tuples are arranged in a list. We can then iterate through this list to access the key-value pairs. Note that while iterating through this list, two variables need to be specified in the for loop which would be mapped to the key and value in the tuple, respectively.\nprint(stationery.items())\n\ndict_items([('pens', ['ball', 'fountain']), ('paper', ['A4', 'A3', 'A2'])])\nfor k1, v1 in stationery.items():\n    print(f\"The key is {k1} and its value is {v1}\")\n\nThe key is pens and its value is ['ball', 'fountain']\nThe key is paper and its value is ['A4', 'A3', 'A2']\nJust like lists, we can modify the contents of a dictionary by adding or removing key-value pairs. When adding a key-value pair if the key doesn’t exists then a new key would be created while if the key is already present then its value would be modified.\nNumbers = {1:\"one\", 2:\"two\"}\nprint(Numbers)\nNumbers[3] = \"three\"\nprint(Numbers)\nNumbers[2] = \"dos\"\nprint(Numbers)\n\n{1: 'one', 2: 'two'}\n{1: 'one', 2: 'two', 3: 'three'}\n{1: 'one', 2: 'dos', 3: 'three'}\ndel(Numbers[2])\nprint(Numbers)\n\n{1: 'one', 3: 'three'}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "Dictionaries.html#dict-comprehensions",
    "href": "Dictionaries.html#dict-comprehensions",
    "title": "9  Dictionaries",
    "section": "9.2 Dict comprehensions",
    "text": "9.2 Dict comprehensions\nYet another way to initialize a dictionary is via dict comprehensions. Just like list comprehensions, here a dictionary is created by processing elements in a list. The code below creates a dictionary with numbers and their squares as key-value pairs.\n\nnew_dict = {x: x**2 for x in range(1,5)}\nprint(new_dict)\n\n{1: 1, 2: 4, 3: 9, 4: 16}\n\n\n\nQuiz: Given a dictionary: d1 = {1:“one”, 2:“two”, 3:“three”} Write a code to check if “two” is present 1) as a key and 2) as a value.\n\n\n\nShow answer\nd1 = {1:\"one\", 2:\"two\", 3:\"three\"}\nif(\"two\" in d1.keys()):\n    print('\"two\" is a key in d1')\nif(\"two\" in d1.values()):\n    print('\"two\" is a value in d1')\n    \n# Alternate solution\nprint(\"Alternate solution\")\nfor k1,v1 in d1.items():\n    if(\"two\" == k1):\n        print('\"two\" is a key in d1')\n    if(\"two\" == v1):\n        print('\"two\" is a value in d1')\n\n\n\"two\" is a value in d1\nAlternate solution\n\"two\" is a value in d1",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "Files.html",
    "href": "Files.html",
    "title": "10  File Handling",
    "section": "",
    "text": "10.1 Reading files\nSaving and retrieving information is frequently required when working with computer programs. Python has methods to read and write files. In addition, there are some libraries that can facilitate working with specialized file types. For reading a file, a file handler needs to be initiated which is an object that act as an interface to that file. A file handler incorporates information about the file along with its path and the mode in which the file is available for processing. The mode here refers to the way the file would be opened i.e. for reading, writing, etc. The open function takes name of the file as an argument along with mode and returns the corresponding file handler. This file handler object is iterator and can be considered as a collection having of all the lines in the file. Once done with reading the contents for the file, the file handler must be closed using the close function.\nTo read a file using the open function, we will pass the file name as the first argument and the mode i.e. r are the second argument. Note that when we given only the file name as an argument, the file should be present in the current working directory. If a file from another folder needs to be accessed then we need to give the full path for that file. To check the working directory path, pwd command can be used.\npwd\n\n'C:\\\\Users\\\\bioinfo guru\\\\OneDrive - bioinfo.guru\\\\Documents\\\\python_book'\nWe can used the Jupyter magic command %load to display the contents a text file within the notebook as shown below.\n# %load test_file.txt\nThis is a test file for Python.\nThis file has .txt extension.\n# test_file.txt should be present in the current working directory.\n\nFH1 = open('test_file.txt','r')\n\nprint(f\"The file {FH1.name} is open in {FH1.mode} mode.\")\n\n# print all the lines in the file.\nfor x in FH1:\n    print(x)\nFH1.close()\n\nThe file test_file.txt is open in r mode.\nThis is a test file for Python.\n\nThis file has .txt extension.\nOften it is useful to remove the newline character (\\n) at the end of the lines since the print fuction add as newline by default. This can be achieved using the rstrip() function. This function without any argument remove the last character in the string and return a copy of the modified string.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File Handling</span>"
    ]
  },
  {
    "objectID": "Files.html#writing-files",
    "href": "Files.html#writing-files",
    "title": "10  File Handling",
    "section": "10.2 Writing files",
    "text": "10.2 Writing files\nFor writing content to a file the open function should be called with ‘w’ as the mode. When a file is opened in the write mode, a new file is created. In case there the file already exists then its contents are overwritten (without warning!). write function is used to write content to a file. We can also use print with file attribute to write to file instead of printing on screen.\n\nFH_out = open('temp_file.txt', 'w')\nFH_out.write(\"This is the first sentence.\\n\")\nprint(\"This is the second sentence.\", file=FH_out)\nFH_out.close()\n\n\n# %load temp_file.txt\nThis is the first sentence.This is the second sentence.\n\n\nFH2 = open('temp_file.txt','r')\nfor lines in FH2:\n    print(lines)\nFH2.close()\n\nThis is the first sentence.\n\nThis is the second sentence.\n\n\n\nTo append contents to an existing file, it should be opened with ‘a’ option instead of ‘w’.\n\nFH_out = open('temp_file.txt','a')\nFH_out.write(\"This is the third sentence.\\n\")\nFH_out.write(\"This is the \\t fourth sentence.\\n\")\nFH_out.close()\n\n\nFH3 = open('temp_file.txt','r')\nfor lines in FH3:\n    lines = lines.rstrip('\\n')\n    print(lines)\nFH3.close()\n\nThis is the first sentence.\nThis is the second sentence.\nThis is the third sentence.\nThis is the      fourth sentence.\n\n\nThe readlines function can be used to get a list having lines of the file as elements.\n\nFH4 = open('temp_file.txt','r')\nall_lines = FH4.readlines()\nprint(all_lines)\nFH4.close()\n\n['This is the first sentence.\\n', 'This is the second sentence.\\n', 'This is the third sentence.\\n', 'This is the \\t fourth sentence.\\n']",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File Handling</span>"
    ]
  },
  {
    "objectID": "Files.html#the-with-keyword",
    "href": "Files.html#the-with-keyword",
    "title": "10  File Handling",
    "section": "10.3 The with keyword",
    "text": "10.3 The with keyword\nWe can also read and write file using the with keyword. Here some action are performed on the file object within the with block. This approach automatically closes the when the with block is over.\n\nwith open(\"temp123.txt\", \"w\") as FH_OUT:\n    print(\"Hello\", file=FH_OUT, end=\" \") \n    print(\"World!\", file=FH_OUT)\nprint(\"Done\")\n\nDone\n\n\n\nwith open(\"temp123.txt\", \"a\") as FH_OUT:\n    print(\"hi\", file=FH_OUT)\n\n\nwith open(\"temp123.txt\",\"r\") as FH:\n    for line in FH.readlines():\n        print(line)\n\nHello World!\n\nhi\n\n\n\n\nQuiz: Write a program to print the third line of a text file.\n\n\n\nShow answer\n#temp_file.txt should be there in the current directory\nFH = open('temp_file.txt','r')\nall_lines = FH.readlines()\nprint(all_lines[2])",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File Handling</span>"
    ]
  },
  {
    "objectID": "Files.html#working-with-multiple-files",
    "href": "Files.html#working-with-multiple-files",
    "title": "10  File Handling",
    "section": "10.4 Working with multiple files",
    "text": "10.4 Working with multiple files\nMany a times we need to process multiple files such that we cannot use individual file names to open and therefore we need a way to programmatically access all the files in a folder. To do this, we have a few options in Python. Libraries such as os and glob provides functionality to iterate over files in a folder. Using the glob function from the glob library, the code below creates a list of files with name starting with “temp” and having a “.txt” extension.\n\nimport glob\ntxt_files = glob.glob(\"temp*.txt\")\nprint(txt_files)\n\n['temp123.txt', 'temp_file.txt']\n\n\nWe can now iterate through this list of files and print their contents. The line_count variable stores the number of lines in each file and is printed after iterating through the contents of a particular file.\n\nfor f in txt_files:\n    line_count = 0\n    print(f'Reading file {f}')\n    FH = open(f, 'r')\n    for line in FH:\n        print(\"\\t\"+line.rstrip(\"\\n\"))\n        line_count += 1\n    FH.close()\n    print(f'{f} has {line_count} line(s).')\n\nReading file temp123.txt\n    Hello World!\ntemp123.txt has 1 line(s).\nReading file temp_file.txt\n    This is the first sentence.\n    This is the second sentence.\n    This is the third sentence.\n    This is the      fourth sentence.\ntemp_file.txt has 4 line(s).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File Handling</span>"
    ]
  },
  {
    "objectID": "Numpy.html",
    "href": "Numpy.html",
    "title": "11  NumPy",
    "section": "",
    "text": "11.1 Reading data from file\nA Python library for scientific computing. It features multidimensional array objects along with an assortment of functions optimized for fast computation. To use this library we first need to import it as shown below. As a convention, the numpy library is imported with an alias np. This will give us access to all the functions within the NumPy library. Let’s create a numpy array.\nAlthough the array looks like a list but it has very different properties and functions associated with it as compared to the python list. An important difference between a list and an ndarray is that the former can have elements of muliple data types while the later can only contain elements of same data type. There are multiple built-in function to create and manipulate arrays for numerical analysis. Let’s have a better understanding of the differences between lists and ndarrays by looking at some the functions associated with arrays. For instance, there are no in-built functions to change the shape of a list or to transpose a list whereas these operations can be done seemlessly with ndarrays. The shape function returns the dimensions of an ndarray as a tuple and the reshape function changes the shape of an ndarray given a tuple.\nAt times, there is a need to change the orientation of the data i.e. the rows in a matrix should be arranged as columns. This can be achieve using the transpose functions. The .T attribute of a numpy array does the same operation. In addition, to get all the values of a multidimensional as a 1D array, use the ravel function. This flattening of multidimensional array is useful when we want to iterate over all the elements in an array without considering the dimensions. The output of ravel function is equivalent to the output of reshape(-1).\nThere are various functions available in NumPy to create arrays e.g. zeros, ones, empty, random.rand can be used to create an ndarray having all the values as zero, one, no value, or random values, respectively. These three functions take shape of the array as an argument and data type can be optionally specified. arange is another function that can be used to initialize an array with specific values. This function is similar to the range function with a difference that it return an array while the range function returns a list.\nWhen using the arange function, we need to specify the spacing (step) between the numbers that we want to generate within a range of numbers. Let’s say, we need to generate a specific number of equally-spaced points within a range of two numbers. Now arange function is not suitable since there is no option to specify total number of points. In this case, linspace function can be used which takes three numbers as argument, the first two numbers specify the range (both number included) and the third number specifies the number of values to return. The linspace function automatically figures out the ‘step’ or spacing between the numbers.\nNumpy has genfromtxt function that comes handy for reading data from text files. The example below show read a csv file using this function. The file test1.csv has five rows with each row having three values separated by comma.\n# %load test1.csv\n1, 1, 1\n2, 4, 8\n3, 9, 27\n4, 16, 64\n5, 25, 125\ninp_data = np.genfromtxt(\"test1.csv\", delimiter=\",\")\nprint(inp_data)\nprint(inp_data.shape)\n\n[[  1.   1.   1.]\n [  2.   4.   8.]\n [  3.   9.  27.]\n [  4.  16.  64.]\n [  5.  25. 125.]]\n(5, 3)\n# slice of the matrix\nsub_matrix = inp_data[1:4]\nprint(sub_matrix)\n\n[[ 2.  4.  8.]\n [ 3.  9. 27.]\n [ 4. 16. 64.]]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Numpy.html#writing-data-to-file",
    "href": "Numpy.html#writing-data-to-file",
    "title": "11  NumPy",
    "section": "11.2 Writing data to file",
    "text": "11.2 Writing data to file\nNumpy has savetxt function that can be used to save numpy arrays to a text file in e.g. csv format. There is an option to change the delimiter. The example below shows writing a csv file using this function with space as a delimiter. The fmt argument is used to specify the format in which to write the data.\n\nnp.savetxt(\"test2.csv\",sub_matrix, delimiter=\" \", fmt='%d')\n\n\n# %load test2.csv\n2 4 8\n3 9 27\n4 16 64",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Numpy.html#slicing-multidimensional-arrays",
    "href": "Numpy.html#slicing-multidimensional-arrays",
    "title": "11  NumPy",
    "section": "11.3 Slicing multidimensional arrays",
    "text": "11.3 Slicing multidimensional arrays\nJust like we can splice a string or list, slicing of numpy arrays can also be performed. While in case of a sting or a list the slice operator takes the start and end positions, in the case of ndarrays, the slice operator would take as many start and end combinations as the dimensions of the ndarray. Which means that slicing can be performed for each dimension of a multidimensional ndarray. In the example below, we first create a three dimensional array having values from 0 to 27. Note that the zeroth element of this 3D array is a 2D array (with values 0 to 8). Similarly, the first element of this 3D array is another 2D array (with values 9 to 17). Next, using slicing, we’ll print one of the number of from this 3D array.\n\narray_3d = np.arange(0,27).reshape(3,3,3)\nprint(array_3d)\n\n[[[ 0  1  2]\n  [ 3  4  5]\n  [ 6  7  8]]\n\n [[ 9 10 11]\n  [12 13 14]\n  [15 16 17]]\n\n [[18 19 20]\n  [21 22 23]\n  [24 25 26]]]\n\n\n\nprint(array_3d.shape)\nprint(array_3d[0,2,1])\n\n(3, 3, 3)\n7\n\n\n\n\n\nThe figure shows the parsing of the slice operator for a 3D array.\n\n\n\nprint(array_3d[:,:,0])\n\n[[ 0  3  6]\n [ 9 12 15]\n [18 21 24]]\n\n\n Quiz: What would be the slice operator for array_3d to get the following output  [[[10 11]    [13 14]]   [[19 20]    [22 23]]]  \n\n\nShow answer\nprint(array_3d[1:3,:2,1:3])",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Numpy.html#combining-arrays",
    "href": "Numpy.html#combining-arrays",
    "title": "11  NumPy",
    "section": "11.4 Combining arrays",
    "text": "11.4 Combining arrays\nThe Numpy arrays can be combined using concatenate function. All the arrays that are to be combined must have same number of dimensions. The arrays to be joined as passed as a tuple and an axis can be specified to indicate the direction along which to join the arrays. The arrays can be joined along row-wise or column-wise by specifing axis as 0 or 1, respectively. Note that the dimensions for all the arrays along the concatenation axis must be identical. That is to say that, e.g., when combining two or more arrays along rows - the number of rows in all the arrays should be same.\n\nprint(np.arange(1,5))\n\n[1 2 3 4]\n\n\n\narr1 = np.arange(1,5).reshape(2,2)\narr2 = np.array([[5,6]]) #note the square brackets\n\nprint(arr1.shape)\nprint(arr2.shape)\n\n(2, 2)\n(1, 2)\n\n\n\narr3 = np.concatenate((arr1,arr2), axis=0) \nprint(arr3)\n\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe above code won’t work with axis=1 because the number of rows in the two arrays is not same. We can transpose the arr2 and then concatenate it with arr1 along axis=1.\n\narr4 = np.concatenate((arr1, arr2.T), axis=1) #note the .T\nprint(arr4)\n\n[[1 2 5]\n [3 4 6]]\n\n\nSimilar, output can be generated using the vstack and hstack functions as shown below.\n\nprint(np.vstack((arr1,arr2)))\nprint(np.hstack((arr1,arr2.T)))\n\n[[1 2]\n [3 4]\n [5 6]]\n[[1 2 5]\n [3 4 6]]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Numpy.html#broadcasting",
    "href": "Numpy.html#broadcasting",
    "title": "11  NumPy",
    "section": "11.5 Broadcasting",
    "text": "11.5 Broadcasting\nWhen performing arithmetic operations with arrays of different sizes, numpy has a an efficient way of broadcasting the array with lower dimensions to match the dimensions of larger array. Broadcasting can be thought of as creating replicas of the original array. This vectorized array operation is a lot faster than conventional looping in Python.\n\narr1 = np.arange(1,5).reshape(2,2)\narr2 = np.array([[5,6]]) #note the square brackets\nprint(arr1)\nprint(arr2)\n\n[[1 2]\n [3 4]]\n[[5 6]]\n\n\nWhen we multiply the two arrays (arr1 * arr2) the arr2 would be broadcasted such as its shape would change from (1,2) to (2,2). Now, with this broadcasted array the multiplication would be performed element-wise. Similarly, when with multiple a scaler with a ndarray, the scaler is broadcasted to match the dimensions of the ndarray followed by element-wise multiplication.\n\nprint(arr1*arr2) #arr2 would be broadcasted along rows\n\n[[ 5 12]\n [15 24]]\n\n\n\nprint(arr1*arr2.T) #arr2 would be broadcasted along columns\n\n[[ 5 10]\n [18 24]]\n\n\n\nprint(arr1*2)\n\n[[2 4]\n [6 8]]\n\n\n\nQuiz: Write a program to calculate cube of first 10 natural numbers.\n\n\n\nShow answer\nprint(np.arange(1,11)**3)\n\n\nThis ability to broadcast open up lot of possibilities when working with martices. A simple example is shown be to print table for first ten natural numbers.\n\nnum1 = np.arange(1,11).reshape(1,10)\nall_ones = np.ones((10,10), dtype=int)\ntable_10 = all_ones*num1*num1.T\nprint(table_10)\n\n[[  1   2   3   4   5   6   7   8   9  10]\n [  2   4   6   8  10  12  14  16  18  20]\n [  3   6   9  12  15  18  21  24  27  30]\n [  4   8  12  16  20  24  28  32  36  40]\n [  5  10  15  20  25  30  35  40  45  50]\n [  6  12  18  24  30  36  42  48  54  60]\n [  7  14  21  28  35  42  49  56  63  70]\n [  8  16  24  32  40  48  56  64  72  80]\n [  9  18  27  36  45  54  63  72  81  90]\n [ 10  20  30  40  50  60  70  80  90 100]]\n\n\n\nnum1\n\narray([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10]])\n\n\n\n#Print tables as seen in math books\ntable_arr = np.empty((5,1), dtype=\"&lt;U200\")\nnum2 = np.arange(1,6)\nfor x in num2:\n    for y in num2:\n        s = f\"{x:&gt;2} X {y:&gt;2} = {x*y:&lt;4}\"\n        table_arr[y-1][0] = table_arr[y-1][0]+s\n# iterate over the array to print each row as a string\n# the slice operator is used to remove square brackets and quotes\nfor i in range(len(table_arr)):\n    print(np.array2string(table_arr[i])[3:-2])\n\n1 X  1 = 1    2 X  1 = 2    3 X  1 = 3    4 X  1 = 4    5 X  1 = 5   \n1 X  2 = 2    2 X  2 = 4    3 X  2 = 6    4 X  2 = 8    5 X  2 = 10  \n1 X  3 = 3    2 X  3 = 6    3 X  3 = 9    4 X  3 = 12   5 X  3 = 15  \n1 X  4 = 4    2 X  4 = 8    3 X  4 = 12   4 X  4 = 16   5 X  4 = 20  \n1 X  5 = 5    2 X  5 = 10   3 X  5 = 15   4 X  5 = 20   5 X  5 = 25",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Numpy.html#functions-for-ndarrays",
    "href": "Numpy.html#functions-for-ndarrays",
    "title": "11  NumPy",
    "section": "11.6 Functions for ndarrays",
    "text": "11.6 Functions for ndarrays\nNumpy comes with a lot of useful functions that facilitates working with ndarrays. Readers are encourages to refer to the NumPy documentation for details.\nwhere()\nThe where function is used to get the indcies of values based on certain condition(s). The get the values corresponding to those indcies, we can slice the original array with the output indcies.\n\narr1 = np.linspace(0,100,10, dtype='int')\nprint(\"arr1 indcies where the value is greater than 50:\")\nprint(np.where(arr1 &gt; 50))\nprint(\"arr1 elements where the value is greater than 50:\")\nprint(arr1[np.where(arr1 &gt; 50)])\n\narr1 indcies where the value is greater than 50:\n(array([5, 6, 7, 8, 9], dtype=int64),)\narr1 elements where the value is greater than 50:\n[ 55  66  77  88 100]\n\n\nsort()\nThe values in a numpy array can be sorted along different axes using the sort function. Also, all the values can be sorted after flattening the array by passing the None to the axis argument. This function returns the sorted array and the original array remains unchanged.\n\narr2 = np.vstack((arr1,np.linspace(100,1,10, dtype='int')))\nprint(arr2)\n\n[[  0  11  22  33  44  55  66  77  88 100]\n [100  89  78  67  56  45  34  23  12   1]]\n\n\n\nprint(\"Sorting row-wise\")\nprint(np.sort(arr2, axis=1))\nprint(\"Sorting column-wise\")\nprint(np.sort(arr2, axis=0))\n\nSorting row-wise\n[[  0  11  22  33  44  55  66  77  88 100]\n [  1  12  23  34  45  56  67  78  89 100]]\nSorting column-wise\n[[  0  11  22  33  44  45  34  23  12   1]\n [100  89  78  67  56  55  66  77  88 100]]\n\n\n\nprint(\"Sorting the flattened array\")\nprint(np.sort(arr2,axis=None))\n\nSorting the flattened array\n[  0   1  11  12  22  23  33  34  44  45  55  56  66  67  77  78  88  89\n 100 100]\n\n\nStatistics\nBelow are examples of some of the functions available in numpy for order and descriptive statistics. The axis argument can be used to calculate statistics along a specific dimension - zero means along the columns and one is for row-wise calculations.\n\n# calculate range (max - min)\n# Here ptp means 'peak-to-peak'\nprint(arr2)\nprint(\"Column-wise range\")\nprint(np.ptp(arr2,axis=0))\n\n[[  0  11  22  33  44  55  66  77  88 100]\n [100  89  78  67  56  45  34  23  12   1]]\nColumn-wise range\n[100  78  56  34  12  10  32  54  76  99]\n\n\nThe percentile function return the q-th percentile for given data. This function take two positional arguments - data and q. The second argument (q-th percentile) can be an number or a list of numbers.\n\n#calculate 50-th percentile\nprint(\"50th percentile along the columns\")\nprint(np.percentile(arr2,50, axis=0))\nprint(\"25th, 50th, and 75th percentile along the rows\")\nprint(np.percentile(arr2,[25,50,75], axis=1))\n\n50th percentile along the columns\n[50.  50.  50.  50.  50.  50.  50.  50.  50.  50.5]\n25th, 50th, and 75th percentile along the rows\n[[24.75 25.75]\n [49.5  50.5 ]\n [74.25 75.25]]\n\n\n\n#calculate mean, standard deviation, and variance\nprint(np.mean(arr2, axis=0))\nprint(np.std(arr2, axis=0))\nprint(np.var(arr2, axis=0))\n\n[50.  50.  50.  50.  50.  50.  50.  50.  50.  50.5]\n[50.  39.  28.  17.   6.   5.  16.  27.  38.  49.5]\n[2500.   1521.    784.    289.     36.     25.    256.    729.   1444.\n 2450.25]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html",
    "href": "Matplotlib.html",
    "title": "12  Matplotlib",
    "section": "",
    "text": "12.1 Styling plots\nMatplotlib is a Python library for data visualization. It offers variety of functions to plot different types of graphs which can be customised to create high quality figures. The pyplot function in this library is used for instantiating a matplotlib graph object. The plot function draws a line plot given two sequences of equal length. The get the scatter plot use scatter. Properties such as line-width, line-color, marker-type, etc. can be easily customized using the appropriate keyword arguments. The pyplot object also has functions for decorating the plots with axis-labels, title, text, legend, etc. The show function renders the plot.\nA plot rendered using the plot function can be styled using specific keyword arguments to control the layout and/or size of different elements within the plot. To customize the marker and line styles, marker and linestyle keyword arguments can be used. Similarly, color (or c) and linewidth (or lw) keyword arguments control the color and width of the line.\nIn addition, for the plot function, styling can also be done using a format string which specifies different styling attributes. The syntax for this format string comprises of a single letter code for marker style, line style, and color (preferably in this order). The “mlc” format string can be passed as an argument to the plot function. This format string can have all three components or less as requried. Note that if either marker style or line style character is missing then the plotting of marker or line is skipped. And if both marker and line styles are not there then a solid line is plotted with the specified color. The figure below shows data used above in two different representations. On left, the plot uses '^:b' format string while on the right graph uses two different format strings – ':r' (dotted line in red) and '^k' (triangle in black) – in the two calls to the plot function.\nThe image below shows some for the options for the marker and line styles available in matplotlib. The character given in parenthesis is used to plot the corresponding marker or line style. Note that these style can further be customized as required, for details please have look at the pyplot.plot documentation.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html#components-of-a-matplotlib-figure",
    "href": "Matplotlib.html#components-of-a-matplotlib-figure",
    "title": "12  Matplotlib",
    "section": "12.2 Components of a matplotlib figure",
    "text": "12.2 Components of a matplotlib figure\nIn addition to the styling options discussed above, matplotlib offers several option to control the aesthetics of a plot. The image below shows the different customizable elements in a matplotlib figure. These elements are accessible via different function available for the pyplot object or the axes object. The axes object is accessible through the gca function for the pyplot object.\n\n\n\n\n\n\n\n\n\nSome of the components of this figure can be modified directly using the pyplot object. E.g., the axes label can be changed using the xlabel and ylabel functions available for the pyplot object. However, to change the x-axis ticks, there is no direct way to do this using the pyplot object. So we need to create an axes object to modify x-ticks. The set_ticks function available for the axes.xaxis object can ge used to specify a list having locations for xticks. Similarly, y-ticks can be customized using the corresponding function for the yaxis. We’ll also remove the top and right borders using spines atribute for the axes object.\n\nx = range(1,11)\ny = [a**2 for a in x]\nplt.plot(x,y) #line plot\nplt.scatter(x,y) #scatter plot\nplt.xlabel(\"Number\")\nplt.ylabel(\"Square\")\nax = plt.gca()\nax.xaxis.set_ticks(range(1,11))\nax.yaxis.set_ticks(range(0,101,10))\nax.spines[[\"right\",\"top\"]].set_visible(False)\nplt.show()\n\n\n\n\n\n\n\n\nWe can also have multiple plots in one graph i.e. different plots sharing the same axes.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\nplt.scatter(x,y,marker=\"^\", color=\"red\")\nplt.scatter(x,z,marker=\"*\", color=\"purple\")\nplt.xlabel(\"Number\", fontsize=12)\nplt.ylabel(\"Value\", fontsize=12)\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.legend([\"Squares\",\"Cubes\"])\nplt.show()\n\n\n\n\n\n\n\n\nMatplotlib has a variety of in-built graph types that can be used to display information as required. Below are examples of some of the plots available in matplotlib. The title of these plots represent the corresponding function avaiable for the pyplot object.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html#error-bars",
    "href": "Matplotlib.html#error-bars",
    "title": "12  Matplotlib",
    "section": "12.3 Error bars",
    "text": "12.3 Error bars\nThe errorbar function can be used to draw a plot with error bars. The yerr keyword argument specifies the size of the errorbars. By default, a line is drawn connecting the data points, which can be changed using the fmt argument. To plot error bars with ploting the data points, use fmt=\"none\". In this example, we’ll use the 2D numpy array having table of numbers (see the chapter on NumPy for details). The mean value along the rows of the ndarray are plotted as dots and standard deviation as the error bars.\n\nnum1 = np.arange(1,11).reshape(1,10)\nall_ones = np.ones((10,10), dtype=int)\ntable_10 = all_ones*num1*num1.T\n\nplt.errorbar(num1[0], np.mean(table_10, axis=0), yerr=np.std(table_10, axis=0),\n            label=\"Standard deviation\", fmt=\"o\")\nplt.legend(loc='upper left')\nplt.gca().xaxis.set_ticks(num1.T)\nplt.xlabel(\"Number\")\nplt.ylabel(\"Mean\")\nplt.show()\n\n\n\n\n\n\n\n\nWe can also read a csv file which has the values for the data points and error bars in two columns. E.g. the code below reads a csv file and then make an errorbar plot using values in the two columns. The loadtxt function from numpy library is used to read the csv file in to a numpy array.\n\n# %load mean_std.csv\nMean, Std\n 5.5, 2.87228132\n11.0, 5.74456265\n16.5, 8.61684397\n22.0, 11.48912529\n27.5, 14.36140662\n33.0, 17.23368794\n38.5, 20.10596926\n44.0, 22.97825059\n49.5, 25.85053191\n55.0, 28.72281323\n\n\ndata_csv = np.loadtxt(\"mean_std.csv\", delimiter=',', skiprows=1) # skip the header row\ndata_csv\n\narray([[ 5.5       ,  2.87228132],\n       [11.        ,  5.74456265],\n       [16.5       ,  8.61684397],\n       [22.        , 11.48912529],\n       [27.5       , 14.36140662],\n       [33.        , 17.23368794],\n       [38.5       , 20.10596926],\n       [44.        , 22.97825059],\n       [49.5       , 25.85053191],\n       [55.        , 28.72281323]])\n\n\nTo get the number of rows in the numpy array, the shape attribute is used which return a tuple having number of rows and columns. The number of rows in the array is then passed to the range function to be used as data for the x-axis. For y-axis values and error bars, first and second columns of the array are used, respectively.\n\nplt.errorbar(range(data_csv.shape[0]), data_csv[:,0], yerr=data_csv[:,1], label=\"Standard deviation\", fmt=\"o\")\nplt.gca().xaxis.set_ticks(range(data_csv.shape[0]))\nplt.xlabel(\"Number\")\nplt.ylabel(\"Mean\")\nplt.show()\nplt.show()\n\n\n\n\n\n\n\n\nThe fill_between function can be used to plot standard deviation as a shaded region instead of error bars. This function takes two y values corresponding to the upper and lower bounds of the region to be filled. Given our data, we’ll create y_upper and y_lower arrays by adding and subtracting standard deviation from the mean, respectively. The alpha argument adjusts the transparency of the shaded region and takes a value between 0 (full transparency) and 1 (no transparency).\n\ny_upper = np.mean(table_10, axis=0) + np.std(table_10, axis=0)\ny_lower = np.mean(table_10, axis=0) - np.std(table_10, axis=0)\nplt.plot(num1[0], np.mean(table_10, axis=0))\nplt.fill_between(num1[0], y_upper, y_lower, alpha=0.2)\nplt.xlabel(\"Number\")\nplt.ylabel(\"Mean\")\nax = plt.gca()\nax.xaxis.set_ticks(num1[0])\nax.spines[[\"top\",\"right\"]].set_visible(False)\nplt.show()\n\n\n\n\n\n\n\n\n\nQuiz: Write a program to make a graph as shown below.\n\n\n\n\n\n\n\n\n\n\n\n\nShow answer\ny = [a**2 for a in x]\nplt.barh(x,y, height=0.5)\nplt.xlabel(\"Value\")\nplt.ylabel(\"Number\")\nplt.yticks(range(1,11))\nplt.legend([\"Square\"], loc=\"lower right\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html#subplots",
    "href": "Matplotlib.html#subplots",
    "title": "12  Matplotlib",
    "section": "12.4 subplots",
    "text": "12.4 subplots\nMany a time we need to plot multiple graphs in one figure for effecient visual analysis. In Matplotlib terminilogy these plots are refered to as subplots. The pyplot class has subplots function that return a figure and and axes object. These can be used to access and manipulated different elements of the graph. In addition, subplots can take as argument the total number of plots to create a figure. This function has a keyword argument figsize to specify the size of the plot.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nfig, ax = plt.subplots(2,1,sharex=True) #two rows and one column\n\nax[0].scatter(x,y,marker=\"^\", color=\"red\")\nax[1].scatter(x,z,marker=\"*\", color=\"purple\")\nax[1].set_xlabel(\"Number\")\nax[0].set_ylabel(\"Squares\")\nax[1].set_ylabel(\"Cubes\")\nplt.show()\n\n\n\n\n\n\n\n\nThe subplots in the above figure can be stacked horizontally by changing the subplots statement to plt.subplots(1,2).\n\n\n\n\n\n\n\n\n\nSimilarly, we can create different arrangements for subplots and save an image using savefig function of the figure object. The resolution of the resulting image can be controlled using the dpi argument. The alphaargument in the code below is used to make the bars transparent.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nfig, ax = plt.subplots(2,2) #create subplots with two rows and two columns\nax[0,0].scatter(x,y,marker=\"^\", color=\"red\")\nax[0,1].bar(x,y,color=\"red\")\n\nax[1,0].scatter(x,z,marker=\"*\", color=\"purple\")\nax[1,0].bar(x,z,color=\"purple\",alpha=0.1)\nax[1,1].bar(x,z,color=\"purple\")\n\nfig.savefig(\"subplot.png\", dpi=300)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html#subplot-without-s",
    "href": "Matplotlib.html#subplot-without-s",
    "title": "12  Matplotlib",
    "section": "12.5 subplot (without ‘s’)",
    "text": "12.5 subplot (without ‘s’)\nThe subplot() function is similar to subplots with a difference that it take an additional argument - index. This can be used to make axes span multiple columns within the subplot.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nax1 = plt.subplot(2,1,1) \nax2 = plt.subplot(2,2,3)\nax3 = plt.subplot(2,2,4)\n\nax1.scatter(x,y,marker=\"^\", color=\"red\")\nax1.bar(x,y, color=\"red\",alpha=0.1)\nax2.scatter(x,z,marker=\"*\", color=\"purple\")\nax3.bar(x,z,color=\"purple\")\n\nplt.savefig(\"subplots2.png\",dpi=300)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Matplotlib.html#venn-diagrams",
    "href": "Matplotlib.html#venn-diagrams",
    "title": "12  Matplotlib",
    "section": "12.6 Venn diagrams",
    "text": "12.6 Venn diagrams\nWhen there are multiple set of items, we might want to analyse the logical relationship between the sets. For instance, how many items are common between two or more sets or how many items are uniquely present in a particular set. Venn diagrams are ideally suited to visualize such logical relations across sets. The matplotlib-venn library provides functions to plot Venn diagrams for two or three sets. It can be installed using pip install matplotlib-venn command.\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_venn import venn2\n\nThe venn2 function takes a list having two sets are an argument and plots the two-circle Venn diagram. The size of each set is in proportion to the items in that set. As discussed in the chapter on sets, a set contains only unique values i.e. if there are duplicates then those are removed.\n\nvenn2([set(['A', 'B', 'C', 'D']), set(['D', 'E', 'F'])])\nplt.show()\n\n\n\n\n\n\n\n\nThe fill color can be changed using the set_colors keyword argument and the set_labels argument adds the labels for each set. Both these arguments take a set of two values as a valid input.\n\nvenn2([set(['A', 'B', 'C', 'D']), set(['D', 'E', 'F'])], set_colors=('pink', 'lightgreen'),\\\n      set_labels=('Set1', 'Set2'))\nplt.show()\n\n\n\n\n\n\n\n\nSimilarly, venn3 is used for plotting three sets.\n\nfrom matplotlib_venn import venn3\n\n\nset1 = set(['A', 'B', 'C', 'D'])\nset2 = set(['D', 'E', 'F'])\nset3 = set(['D','F','G', 'H', 'I'])\nvenn3([set1, set2, set3], set_labels=('Set1', 'Set2', 'Set3'))\nplt.show()\n\n{'A', 'C', 'D', 'B'}\n\n\n\n\n\n\n\n\n\nWe can further customize the individual components within these plots using the get_patch_by_id and get_label_by_id attributes for the Venn diagram object.\n\nv = venn3([set1, set2, set3], set_labels=('Set1', 'Set2', 'Set3'))\nv.get_label_by_id('100').set_text('F') # label for First set\nv.get_label_by_id('010').set_text('S') # label for Second set\nv.get_label_by_id('001').set_text('T') # label for Third set\nv.get_label_by_id('110').set_text('FS') # label for intersection of First and Second \nv.get_label_by_id('011').set_text('ST') # label for intersection of Second and Third\nv.get_label_by_id('101').set_text('FT') # label for intersection of First and Third\nv.get_label_by_id('111').set_text('FST') # label for intersection of all three\nv.get_patch_by_id('111').set_color('white') # color for intersection of all three\nv.get_patch_by_id('011').set_color('yellow') # color for intersection of Second and Third\n\n\n\n\n\n\n\n\nAn alternate approach to plot a Venn diagram is to specify the values for the subsets within the Venn diagram instead of giving three sets. As apparent from the output of the venn3 function above, there are a total of seven values that makes up the diagram. Using the subsets keyword argument for the venn3 function we make a similar plot without give a list of sets as an argument.\n\nvenn3(subsets=(3, 1, 0, 3, 0, 1, 1), set_labels=('Set1', 'Set2', 'Set3'))\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Matplotlib</span>"
    ]
  },
  {
    "objectID": "Pandas.html",
    "href": "Pandas.html",
    "title": "13  Pandas",
    "section": "",
    "text": "13.1 Indexing and Selecting\nPandas is a library that is useful for working with different types of datasets. A dataframe is a pandas object that has a variety of function to process, analyze, and visualize data. It arranges the data in rows and columns. There are multiple ways in which a dataframe can be created. For example, a dictionary with list as values can be converted to a dataframe such that the keys become headers and values (list) are entries in the dataframe. The orientation of the dataframe by default is columns ie keys are considered as column header and values are rows. This behaviour can be changed using the orient argument. When orientation is index, an addtional argument columns can be used to specify column headers.\nThe data in a dataframes are arranged in rows and columns both of which have labels. The get a slice of a dataframe, these labels can used with the loc attribute. The columns and index attributes for a dataframe return an iteratable collection of column labels and index labels. To select a subset of a dataframe using indcies for the rows and columns use iloc. Both loc and iloc takes a slice of row label/range and column label/range. Note that a one-dimensional slice of a dataframe returns a Series object i.e. if we select one column or one row, a Series object would be returned. To convert a series object to a dataframe use to_frame function.\nMulti-indexing is also possible i.e., a row or a column can have more than one label. In such cases, selections can be made by specifing labels as a tuple.\nColumn1\n      Column2\n    \n  \n  \n    \n      0\n      A\n      1\n    \n    \n      1\n      B\n      2\n    \n    \n      2\n      C\n      3\n    \n    \n      3\n      D\n      4\n    \n    \n      4\n      E\n      5\n    \n  \n\n\n\ndf1.columns: \n Index(['Column1', 'Column2'], dtype='object') \n df1.index: \n RangeIndex(start=0, stop=5, step=1)\nColumn1\n    \n  \n  \n    \n      0\n      A\n    \n    \n      1\n      B\n    \n    \n      2\n      C\n    \n    \n      3\n      D\n    \n    \n      4\n      E\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      Column1\n    \n  \n  \n    \n      0\n      A\n    \n    \n      1\n      B\n    \n    \n      2\n      C\n    \n    \n      3\n      D\n    \n    \n      4\n      E\n    \n  \n\n\n\n\n\n\n\n\n\n  \n    \n      \n      Column1\n      Column2\n    \n  \n  \n    \n      2\n      C\n      3\n    \n    \n      3\n      D\n      4\n    \n    \n      4\n      E\n      5\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      Column1\n      Column2\n    \n  \n  \n    \n      2\n      C\n      3\n    \n    \n      3\n      D\n      4\n    \n    \n      4\n      E\n      5",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#dataframe-information",
    "href": "Pandas.html#dataframe-information",
    "title": "13  Pandas",
    "section": "13.2 Dataframe information",
    "text": "13.2 Dataframe information\nPandas offers set of commands to get some basic information about the content of dataframes. Below are some of these command along with their corresponding output.\n\n\n\n\n\n\n  \n    \n      \n      Column1\n      Column2\n    \n  \n  \n    \n      0\n      A\n      1\n    \n    \n      1\n      B\n      2\n    \n    \n      2\n      C\n      3\n    \n    \n      3\n      D\n      4\n    \n    \n      4\n      E\n      5\n    \n  \n\n\n\n\nInformation about this dataframe \ndf1.shape      (5, 2)\ndf1.size       10\ndf1.ndim       2\ndf1.values     [['A' 1]\n ['B' 2]\n ['C' 3]\n ['D' 4]\n ['E' 5]]",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#data-from-and-to-a-csv-file",
    "href": "Pandas.html#data-from-and-to-a-csv-file",
    "title": "13  Pandas",
    "section": "13.3 Data from (and to) a csv file",
    "text": "13.3 Data from (and to) a csv file\nThe read_csv() function can be used to create a dataframe from a csv file. To use one of the columns as indices for the dataframe add the index_col keyword attribute.\n\n# %load test.csv\nName,Age,Country\nSohan,22,India\nSam,21,USA\n\ndf3 = pd.read_csv(\"test.csv\")\ndf4 = pd.read_csv(\"test.csv\", index_col=\"Country\")\ndisplay(df3)\ndisplay(df4)\n\n\n\n\n\n\n  \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      Name\n      Age\n    \n    \n      Country\n      \n      \n    \n  \n  \n    \n      India\n      Sohan\n      22\n    \n    \n      USA\n      Sam\n      21\n    \n  \n\n\n\n\n\nTo write a dataframe to a csv file use to_csv function. The default delimiter is , and can be changed with the sep argument.\n\ndf4.to_csv(\"output.csv\")\n\n\n# %load output.csv\nCountry,Name,Age\nIndia,Sohan,22\nUSA,Sam,21",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#combining-dataframes",
    "href": "Pandas.html#combining-dataframes",
    "title": "13  Pandas",
    "section": "13.4 Combining dataframes",
    "text": "13.4 Combining dataframes\nPandas offers a variety of way to combine dataframes. These methods differ in the options in which the data from two or more dataframes can be combined. Having a good understanding of these functions is vital of effectively working with diverse datasets.\n\nConcat\nPandas has a concat function that takes a list of dataframes and returns a combined dataframe. The axis argument indicates whether the dataframes would be combined across rows or columns. The default is axis=0 i.e. the dataframes are concatenated row-wise. The key argument can be used to add an additional index refering to each of the dataframe that is concatenated.\n\nimport numpy as np\ndf_1 = pd.DataFrame(np.random.uniform(1,2,size=(5, 4)), columns=list('ABCD'))\ndf_2 = pd.DataFrame(np.random.uniform(2,3,size=(5, 4)), columns=list('ABCD'))\n\n\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.710289\n      1.260774\n      1.047939\n      1.342935\n    \n    \n      1\n      1.539253\n      1.610440\n      1.608759\n      1.518317\n    \n    \n      2\n      1.471803\n      1.817016\n      1.757089\n      1.957877\n    \n    \n      3\n      1.621033\n      1.152500\n      1.237414\n      1.457109\n    \n    \n      4\n      1.671551\n      1.689427\n      1.698675\n      1.270451\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      2.511460\n      2.394432\n      2.979061\n      2.699233\n    \n    \n      1\n      2.431831\n      2.324515\n      2.433901\n      2.839483\n    \n    \n      2\n      2.507918\n      2.410554\n      2.192603\n      2.818681\n    \n    \n      3\n      2.969286\n      2.182390\n      2.412281\n      2.181399\n    \n    \n      4\n      2.605576\n      2.750244\n      2.238079\n      2.926454\n    \n  \n\n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],ignore_index=True)\ndisplay(df_new)\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.710289\n      1.260774\n      1.047939\n      1.342935\n    \n    \n      1\n      1.539253\n      1.610440\n      1.608759\n      1.518317\n    \n    \n      2\n      1.471803\n      1.817016\n      1.757089\n      1.957877\n    \n    \n      3\n      1.621033\n      1.152500\n      1.237414\n      1.457109\n    \n    \n      4\n      1.671551\n      1.689427\n      1.698675\n      1.270451\n    \n    \n      5\n      2.511460\n      2.394432\n      2.979061\n      2.699233\n    \n    \n      6\n      2.431831\n      2.324515\n      2.433901\n      2.839483\n    \n    \n      7\n      2.507918\n      2.410554\n      2.192603\n      2.818681\n    \n    \n      8\n      2.969286\n      2.182390\n      2.412281\n      2.181399\n    \n    \n      9\n      2.605576\n      2.750244\n      2.238079\n      2.926454\n    \n  \n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],axis=1)\ndisplay(df_new)\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.710289\n      1.260774\n      1.047939\n      1.342935\n      2.511460\n      2.394432\n      2.979061\n      2.699233\n    \n    \n      1\n      1.539253\n      1.610440\n      1.608759\n      1.518317\n      2.431831\n      2.324515\n      2.433901\n      2.839483\n    \n    \n      2\n      1.471803\n      1.817016\n      1.757089\n      1.957877\n      2.507918\n      2.410554\n      2.192603\n      2.818681\n    \n    \n      3\n      1.621033\n      1.152500\n      1.237414\n      1.457109\n      2.969286\n      2.182390\n      2.412281\n      2.181399\n    \n    \n      4\n      1.671551\n      1.689427\n      1.698675\n      1.270451\n      2.605576\n      2.750244\n      2.238079\n      2.926454\n    \n  \n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],keys=[\"First\",\"Second\"])\ndisplay(df_new)\n\n\n\n\n  \n    \n      \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      First\n      0\n      1.710289\n      1.260774\n      1.047939\n      1.342935\n    \n    \n      1\n      1.539253\n      1.610440\n      1.608759\n      1.518317\n    \n    \n      2\n      1.471803\n      1.817016\n      1.757089\n      1.957877\n    \n    \n      3\n      1.621033\n      1.152500\n      1.237414\n      1.457109\n    \n    \n      4\n      1.671551\n      1.689427\n      1.698675\n      1.270451\n    \n    \n      Second\n      0\n      2.511460\n      2.394432\n      2.979061\n      2.699233\n    \n    \n      1\n      2.431831\n      2.324515\n      2.433901\n      2.839483\n    \n    \n      2\n      2.507918\n      2.410554\n      2.192603\n      2.818681\n    \n    \n      3\n      2.969286\n      2.182390\n      2.412281\n      2.181399\n    \n    \n      4\n      2.605576\n      2.750244\n      2.238079\n      2.926454\n    \n  \n\n\n\n\n\ndisplay(df_new.loc[\"First\"])\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.710289\n      1.260774\n      1.047939\n      1.342935\n    \n    \n      1\n      1.539253\n      1.610440\n      1.608759\n      1.518317\n    \n    \n      2\n      1.471803\n      1.817016\n      1.757089\n      1.957877\n    \n    \n      3\n      1.621033\n      1.152500\n      1.237414\n      1.457109\n    \n    \n      4\n      1.671551\n      1.689427\n      1.698675\n      1.270451\n    \n  \n\n\n\n\n\n\nMerge\nThe merge function in pandas is used combine two dataframes on one or more columns. The on argument takes name(s) of column or index levels to be merged. If on is None (default) then all the columns are considred and in case of identical columns, an intersection is performed. When on is specified and the merged dataframe results in duplicate column names then suffixes argument can be used to indicate the original datafames.\n\n# read a csv file having following data\n# Name,Age,Country\n# Sohan,22,India\n# Sam,21,USA\n\ndf3 = pd.read_csv(\"test.csv\")\ndisplay(df3)\n\n# make a copy of df3\ndf4 = df3.copy(deep=True)\n# add rows to df4\ndf4.loc[2]=[\"Peter\", 20, \"UK\"] \ndf4.loc[len(df4.index)] = [\"Mohan\", 25, \"India\"]\ndisplay(df4)\n\n# merge dataframes\ndf_merged1 = pd.merge(df3,df4)\ndisplay(df_merged1)\n\ndf_merged2 = pd.merge(df3,df4,on=[\"Country\",\"Name\"],\\\n                      suffixes=('_df3', '_df4'))\ndisplay(df_merged2)\n\n\n\n\n\n\n\n  \n    \n      \n      df3\n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      df4\n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n    \n      2\n      Peter\n      20\n      UK\n    \n    \n      3\n      Mohan\n      25\n      India\n    \n  \n\n\n\n\n\n\n\n\n\n  \n    \n      \n      df_merged1\n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n  \n    \n      \n      df_merged2\n    \n    \n      \n      Name\n      Age_df3\n      Country\n      Age_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      22\n    \n    \n      1\n      Sam\n      21\n      USA\n      21\n    \n  \n\n\n\n\n\n\n\nJoin\nThe join function for a dataframe oject is used to combine one or more dataframes. By default the joining is performed along the indcies and the lsuffix and rsuffix arguments can be used to modify column names. In this case, new columns from one of the dataframes are added to the other. The on keyword specifies the index label on which to join the dataframes.\nThe joining of dataframe can be performed with different logics in terms of how to handle the overlapping columns. The diagram below shows the pictorial representation of four options that we have. In these Venn diagrams the darker shade shows the subset that will be selected. Here left refers to the dataframe on which the join function is called and right is the dataframe which goes as the argument for the join function.\n\n\n\n\n\n\n\n\n\n\ndisplay(df3.join(df4,lsuffix='_df3', rsuffix='_df4'))\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country_df3\n      Name_df4\n      Age_df4\n      Country_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\ndisplay(df3.set_index(\"Country\"))\n\n\n\n\n  \n    \n      \n      Name\n      Age\n    \n    \n      Country\n      \n      \n    \n  \n  \n    \n      India\n      Sohan\n      22\n    \n    \n      USA\n      Sam\n      21\n    \n  \n\n\n\n\nTo join df4 to df3 on Country, we need to set the index of df4 to Country. Note that there are two rows with index 0 because there is one row with India in df3 and two such rows in df_4. Also, in the joined dataframe there is no data for UK since there was no row in df3 with UK in Country column. This behaviour can be changed by adding the how argument to join function (see below).\n\ndisplay(df3.join(df4.set_index(\"Country\"),on=\"Country\", lsuffix='_df3', rsuffix='_df4'))\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country\n      Name_df4\n      Age_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      Sohan\n      22\n    \n    \n      0\n      Sohan\n      22\n      India\n      Mohan\n      25\n    \n    \n      1\n      Sam\n      21\n      USA\n      Sam\n      21\n    \n  \n\n\n\n\nTo get the joined dataframe with Country as index, set indcies for both the dataframes to Country.\n\ndisplay(df3.join(df4.set_index(\"Country\"),on=\"Country\", lsuffix='_df3', rsuffix='_df4', how='outer'))\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country\n      Name_df4\n      Age_df4\n    \n  \n  \n    \n      0.0\n      Sohan\n      22.0\n      India\n      Sohan\n      22\n    \n    \n      0.0\n      Sohan\n      22.0\n      India\n      Mohan\n      25\n    \n    \n      1.0\n      Sam\n      21.0\n      USA\n      Sam\n      21\n    \n    \n      NaN\n      NaN\n      NaN\n      UK\n      Peter\n      20\n    \n  \n\n\n\n\n\ndisplay(df3.set_index(\"Country\").join(df4.set_index(\"Country\"),on=\"Country\", lsuffix='_df3', rsuffix='_df4', how=\"outer\"))\n\n\n\n\n  \n    \n      \n      Country\n      Name_df3\n      Age_df3\n      Name_df4\n      Age_df4\n    \n  \n  \n    \n      India\n      India\n      Sohan\n      22.0\n      Sohan\n      22\n    \n    \n      India\n      India\n      Sohan\n      22.0\n      Mohan\n      25\n    \n    \n      USA\n      USA\n      Sam\n      21.0\n      Sam\n      21\n    \n    \n      NaN\n      UK\n      NaN\n      NaN\n      Peter\n      20",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#groupby",
    "href": "Pandas.html#groupby",
    "title": "13  Pandas",
    "section": "13.5 Groupby",
    "text": "13.5 Groupby\nWe can create groups for same values in a column to apply a function to all rows having a particular value.\n\nstudents = [[\"Sam\",\"Peter\",\"Mohan\", \"Mike\"], [\"UG\",\"PG\",\"UG\",\"PG\"], [70,80,90,70]]\ndf_students = pd.DataFrame(students).T\n\ndf_students.columns=[\"Name\",\"Program\",\"Marks\"]\ndisplay(df_students)\n\n\n\n\n  \n    \n      \n      Name\n      Program\n      Marks\n    \n  \n  \n    \n      0\n      Sam\n      UG\n      70\n    \n    \n      1\n      Peter\n      PG\n      80\n    \n    \n      2\n      Mohan\n      UG\n      90\n    \n    \n      3\n      Mike\n      PG\n      70\n    \n  \n\n\n\n\n\ndf_students.set_index(\"Program\", inplace=True)\ndisplay(df_students)\n\n\n\n\n  \n    \n      \n      Name\n      Marks\n    \n    \n      Program\n      \n      \n    \n  \n  \n    \n      UG\n      Sam\n      70\n    \n    \n      PG\n      Peter\n      80\n    \n    \n      UG\n      Mohan\n      90\n    \n    \n      PG\n      Mike\n      70\n    \n  \n\n\n\n\n\ndf_students.groupby(level=\"Program\")[\"Marks\"].mean()\n\nProgram\nPG    75.0\nUG    80.0\nName: Marks, dtype: float64",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#styling",
    "href": "Pandas.html#styling",
    "title": "13  Pandas",
    "section": "13.6 Styling",
    "text": "13.6 Styling\nThe pandas dataframe has a style attribute that return a styler object which has different functions to customize dataframe display. E.g., to highlight minimun and maximum values in a dataframe, the hightlight_min and highlight_max functions for the styler object can be used. The min and max values can be selected column-wise or row-wise by setting the axis argument to 0 or 1, respectively. To highlight min or max value for the entire dataframe use axis = None. The props argument is used to set the highlight properties and takes a valid CSS (Cascading Style Sheet) property.\ndf_1 = pd.DataFrame(np.random.uniform(1,2,size=(5, 4)), columns=list('ABCD'))\ndisplay(df_1.style.highlight_max()\\\n        .set_caption(\"Column-wise highlighting of maximum value\"))\ndisplay(df_1.style.highlight_min(axis=1,props=\"font-weight:bold;background-color:pink;\")\\\n        .set_caption(\"Row-wise highlighting of minimum value\"))\n\n\n\n\n\n  Column-wise highlighting of maximum value\n  \n    \n       \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.036642\n      1.265409\n      1.593481\n      1.470786\n    \n    \n      1\n      1.169744\n      1.747707\n      1.411616\n      1.924018\n    \n    \n      2\n      1.620145\n      1.927595\n      1.532973\n      1.063995\n    \n    \n      3\n      1.895642\n      1.669849\n      1.834086\n      1.254635\n    \n    \n      4\n      1.831751\n      1.220100\n      1.203569\n      1.954389\n    \n  \n\n\n\n\n\n  Row-wise highlighting of minimum value\n  \n    \n       \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.036642\n      1.265409\n      1.593481\n      1.470786\n    \n    \n      1\n      1.169744\n      1.747707\n      1.411616\n      1.924018\n    \n    \n      2\n      1.620145\n      1.927595\n      1.532973\n      1.063995\n    \n    \n      3\n      1.895642\n      1.669849\n      1.834086\n      1.254635\n    \n    \n      4\n      1.831751\n      1.220100\n      1.203569\n      1.954389\n    \n  \n\n\n\n\nWe can also highlight all the values in a dataframe with color gradient. The coloring can be applied to the text or background. The cmap argument for background_gradient and text_gradient functions can be used to customize the coloring based on a colormap.\ndisplay(df_1.style.background_gradient()\\\n        .set_caption(\"Column-wise background gradient\")\\\n        .set_properties(**{\"font-weight\":\"bold\", \"padding\":\"1em\"})\\\n        .format(\"{:.2f}\"))\ndisplay(df_1.style.text_gradient(axis=1, cmap=\"winter\")\\\n        .set_caption(\"Row-wise text gradient\")\\\n        .set_properties(**{\"font-weight\":\"bold\", \"padding\":\"1em\"})\\\n        .format(\"{:.2f}\"))\n\n\n\n\n\n  Column-wise background gradient\n  \n    \n       \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.04\n      1.27\n      1.59\n      1.47\n    \n    \n      1\n      1.17\n      1.75\n      1.41\n      1.92\n    \n    \n      2\n      1.62\n      1.93\n      1.53\n      1.06\n    \n    \n      3\n      1.90\n      1.67\n      1.83\n      1.25\n    \n    \n      4\n      1.83\n      1.22\n      1.20\n      1.95\n    \n  \n\n\n\n\n\n  Row-wise text gradient\n  \n    \n       \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.04\n      1.27\n      1.59\n      1.47\n    \n    \n      1\n      1.17\n      1.75\n      1.41\n      1.92\n    \n    \n      2\n      1.62\n      1.93\n      1.53\n      1.06\n    \n    \n      3\n      1.90\n      1.67\n      1.83\n      1.25\n    \n    \n      4\n      1.83\n      1.22\n      1.20\n      1.95\n    \n  \n\n\n\n\n\nBar charts within dataframe\nThe values in a dataframe can be decorated with bar plots using the bar function for the styler object. In this example, we’ll display the dataframe after applying the following customizations:\n- bar plots with custom color map.\n- format the floats to display upto two decimal places.\n- make the text bold.\n- center align the text in the dataframe.\n- hide the indcies.\n\n\ndf_bar = pd.DataFrame(np.random.uniform(-10,10,size=(5, 4)), columns=list('ABCD'))\nfrom matplotlib.colors import ListedColormap\ncmp = ListedColormap([\"pink\",\"lightblue\"])\ndisplay(df_bar.style\n        .bar(vmin=-10, vmax=10, align=0, cmap=cmp)\\\n        .format(\"{:.2f}\")\\\n        .set_properties(**{\"font-weight\":\"bold\", \"text-align\":\"center\"})\\\n        .set_table_styles([dict(selector='th', props=[('text-align', 'center')])])\\\n        .hide(axis=\"index\")\\\n        .set_caption(\"Dataframe with bar charts\"))\n\n\n\n  Dataframe with bar charts\n  \n    \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      -4.55\n      -7.13\n      -9.91\n      -2.22\n    \n    \n      -6.40\n      5.80\n      -4.14\n      3.11\n    \n    \n      -4.75\n      8.02\n      -0.00\n      3.65\n    \n    \n      -6.30\n      -8.01\n      2.33\n      -0.02\n    \n    \n      -9.94\n      5.72\n      6.49\n      6.30",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Pandas.html#ploting",
    "href": "Pandas.html#ploting",
    "title": "13  Pandas",
    "section": "13.7 Ploting",
    "text": "13.7 Ploting\nDataframe has a plot() function to do basic visualization. The kind attribute for this function can be used to change the plot type.\n\ndf_col1 = pd.DataFrame(np.array(range(1,6))**2)\ndf_col2 = pd.DataFrame(np.array(range(1,6))**3)\n\ndf_comb = pd.concat([df_col1,df_col2], axis=1, ignore_index=True)\ndf_comb.columns = [\"Squares\", \"Cubes\"]\ndf_comb.index = range(1,6)\ndisplay(df_comb)\n\n\n\n\n  \n    \n      \n      Squares\n      Cubes\n    \n  \n  \n    \n      1\n      1\n      1\n    \n    \n      2\n      4\n      8\n    \n    \n      3\n      9\n      27\n    \n    \n      4\n      16\n      64\n    \n    \n      5\n      25\n      125\n    \n  \n\n\n\n\nplot1 = df_comb.plot(title=\"Line Plot\")\nplot2 = df_comb.plot(kind=\"bar\", title=\"Bar Plot\")\n\n\n\n\n\n\n\n\n\n\n\nThe iris dataset\nOne of the popular datasets for learning data analysis is the iris dataset which has data for four iris flower features (sepal length, sepal width, petal length, and petal width). These data are there for the three species namely Iris setosa, Iris versicolour, and Iris virginica. Let’s import this data create a dataframe and practice data visualization.\n\ncsv_url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\n# using the attribute information as the column names\ncol_names = ['Sepal_Length','Sepal_Width','Petal_Length','Petal_Width','Class']\niris =  pd.read_csv(csv_url, names = col_names)\n\n\ndisplay(iris)\nprint(iris.dtypes)\n\n\n\n\n  \n    \n      \n      Sepal_Length\n      Sepal_Width\n      Petal_Length\n      Petal_Width\n      Class\n    \n  \n  \n    \n      0\n      5.1\n      3.5\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      1\n      4.9\n      3.0\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      2\n      4.7\n      3.2\n      1.3\n      0.2\n      Iris-setosa\n    \n    \n      3\n      4.6\n      3.1\n      1.5\n      0.2\n      Iris-setosa\n    \n    \n      4\n      5.0\n      3.6\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      145\n      6.7\n      3.0\n      5.2\n      2.3\n      Iris-virginica\n    \n    \n      146\n      6.3\n      2.5\n      5.0\n      1.9\n      Iris-virginica\n    \n    \n      147\n      6.5\n      3.0\n      5.2\n      2.0\n      Iris-virginica\n    \n    \n      148\n      6.2\n      3.4\n      5.4\n      2.3\n      Iris-virginica\n    \n    \n      149\n      5.9\n      3.0\n      5.1\n      1.8\n      Iris-virginica\n    \n  \n\n150 rows × 5 columns\n\n\n\nSepal_Length    float64\nSepal_Width     float64\nPetal_Length    float64\nPetal_Width     float64\nClass            object\ndtype: object\n\n\nTo get the summary statistics for this dataset we’ll use the describe function for the iris dataframe. This function calculates different statistical parameters for all the columns with numeric data. Notice that this summary would be for the entire data and so might not be of much use. A better approach would be first aggreate the data by species so that we can get summary statistics for each species.\n\niris.describe()\n\n\n\n\n  \n    \n      \n      Sepal_Length\n      Sepal_Width\n      Petal_Length\n      Petal_Width\n    \n  \n  \n    \n      count\n      150.000000\n      150.000000\n      150.000000\n      150.000000\n    \n    \n      mean\n      5.843333\n      3.054000\n      3.758667\n      1.198667\n    \n    \n      std\n      0.828066\n      0.433594\n      1.764420\n      0.763161\n    \n    \n      min\n      4.300000\n      2.000000\n      1.000000\n      0.100000\n    \n    \n      25%\n      5.100000\n      2.800000\n      1.600000\n      0.300000\n    \n    \n      50%\n      5.800000\n      3.000000\n      4.350000\n      1.300000\n    \n    \n      75%\n      6.400000\n      3.300000\n      5.100000\n      1.800000\n    \n    \n      max\n      7.900000\n      4.400000\n      6.900000\n      2.500000\n    \n  \n\n\n\n\n\niris_grp = iris.groupby(by=\"Class\")\niris_grp.describe()['Petal_Length']\n\n\n\n\n  \n    \n      \n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n    \n    \n      Class\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Iris-setosa\n      50.0\n      1.464\n      0.173511\n      1.0\n      1.4\n      1.50\n      1.575\n      1.9\n    \n    \n      Iris-versicolor\n      50.0\n      4.260\n      0.469911\n      3.0\n      4.0\n      4.35\n      4.600\n      5.1\n    \n    \n      Iris-virginica\n      50.0\n      5.552\n      0.551895\n      4.5\n      5.1\n      5.55\n      5.875\n      6.9\n    \n  \n\n\n\n\n\n\nSeaborn library\nThe Seaborn library is data visualization library based on Matplotlib. This library is particularly suitable for ploting with dataframes. The libaray has been specifically designed and develop in way to focus on the data analysis rather than worrying about nuances of drawing plot.\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\np1 = sns.scatterplot(data=iris,x=\"Sepal_Length\",y=\"Petal_Length\",hue=\"Class\")\n\n\n\n\n\n\n\n\nThe seaborn library has dedicated functions to facilitate ploting informative visualizations. E.g., jointplot is used for rendering a scatter plot along with the corresponding data distributions. Similarly, pairplot can be used to render pairwise plots for all the numeric data in a dataframe.\n\nplot1 = sns.jointplot(data=iris,x=\"Sepal_Length\",y=\"Petal_Length\",hue=\"Class\")\nplot2 = sns.pairplot(data=iris,hue=\"Class\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also visualize statistical information graphically, e.g. in the form of a boxplot. For instance, to see the distribution of the values for Petal_Length across the three iris species, we can make a boxplot as follows.\n\nfig, ax = plt.subplots(figsize=(4,3))\nsns.boxplot(data=iris,x=\"Class\", y=\"Petal_Length\", hue=\"Class\", ax=ax)\nplt.show()\n\n\n\n\n\n\n\n\nSimilarly, we can have separate boxplots for all four features as a grid.\n\nfig, ax = plt.subplots(2, 2, figsize=(8,6), sharex=True)\nsns.boxplot(data=iris,x=\"Class\", y=\"Petal_Length\", hue=\"Class\", ax=ax[0,0]).set(xlabel='')\nsns.boxplot(data=iris,x=\"Class\", y=\"Petal_Width\", hue=\"Class\", ax=ax[0,1]).set(xlabel='')\nsns.boxplot(data=iris,x=\"Class\", y=\"Sepal_Length\", hue=\"Class\", ax=ax[1,0]).set(xlabel='')\nsns.boxplot(data=iris,x=\"Class\", y=\"Sepal_Width\", hue=\"Class\", ax=ax[1,1]).set(xlabel='')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNow, let’s say we want to have the boxplot plots for each of the feature grouped together i.e. a graph that shows four sets of boxplots with groups colored according to the species name.\nFor this kind of a plot, we first need to modify (or reformat) our dataframe so that its in the required format. Using the melt function in pandas, the original iris dataframe would be modified such that the values for all four flower features appear one per row. This would allow us to perform statistical calculations (required for boxplot) on all the feature and color the plot based on the species. Notice that the original iris dataframe’s shape is 150 X 5 (which implies a total of 600 datapoints since there are 4 data columns) while the melted dataframe’s shape is 600 X 3.\n\niris_melt = pd.melt(iris, id_vars=['Class'],\\\n                    value_vars=[\"Sepal_Length\",\"Sepal_Width\",\"Petal_Length\",\"Petal_Width\"],\\\n                    var_name='Feature')\niris_melt\n\n\n\n\n  \n    \n      \n      Class\n      Feature\n      value\n    \n  \n  \n    \n      0\n      Iris-setosa\n      Sepal_Length\n      5.1\n    \n    \n      1\n      Iris-setosa\n      Sepal_Length\n      4.9\n    \n    \n      2\n      Iris-setosa\n      Sepal_Length\n      4.7\n    \n    \n      3\n      Iris-setosa\n      Sepal_Length\n      4.6\n    \n    \n      4\n      Iris-setosa\n      Sepal_Length\n      5.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      595\n      Iris-virginica\n      Petal_Width\n      2.3\n    \n    \n      596\n      Iris-virginica\n      Petal_Width\n      1.9\n    \n    \n      597\n      Iris-virginica\n      Petal_Width\n      2.0\n    \n    \n      598\n      Iris-virginica\n      Petal_Width\n      2.3\n    \n    \n      599\n      Iris-virginica\n      Petal_Width\n      1.8\n    \n  \n\n600 rows × 3 columns\n\n\n\n\nfig, ax = plt.subplots(figsize=(8,4))\nplot3 = sns.boxplot(data=iris_melt,x=\"Feature\", y=\"value\",hue=\"Class\", ax=ax)\n\n\n\n\n\n\n\n\nThe catplot function provides an intutive interface to visually analyze the relationship between numerical and categorical data. There are three different options for plot layout – scatter plot or distribution plot or estimate plot – each of which points to an axis-level plot function. The plot selection is made using the kind keyword argument. The table below shows the available options for the kind argument and their corresponding axis-level functions. The size of the plot can be adjusted using the height and aspect keyword arguments.\n\n\n\nCategorical plot\n\n\nkind\n\n\nAxis-level function\n\n\n\n\nScatter plot\n\n\nstrip (default)\n\n\nstripplot()\n\n\n\n\nswarm\n\n\nswarmplot()\n\n\n\n\nDistribution plot\n\n\nbox\n\n\nboxplot()\n\n\n\n\nviolin\n\n\nviolinplot()\n\n\n\n\nboxen\n\n\nboxenplot()\n\n\n\n\nEstimate plot\n\n\npoint\n\n\npointplot()\n\n\n\n\nbar\n\n\nbarplot()\n\n\n\n\ncount\n\n\ncountplot()\n\n\n\nThe code below creates a violin plot using the above data. The x-axis label is removed using the set function for the FacetGrid object and the font size for all the labels is increase using the set_theme function from sns.\n\nsns.set_theme(style=\"white\", font_scale=1.5)\np2 = sns.catplot(data=iris_melt, x=\"Feature\", y=\"value\", kind=\"violin\", \n                 hue=\"Class\", height=4, aspect=2)\np2.set(xlabel=None)\nplt.show()\n\n\n\n\n\n\n\n\nSimilarly, we can make a swarm plot for each feature and color it by species. A swarm plot is like a scatterplot such that the position of the points are to avoid overlap. The catplot function returns a FacetGrid which can be customized to render desired representation. For our data there will be four plots in the facet grid which will be arranged as one row and four columns by default. The code below, makes a feature-wise swarm plot with two columns (col_warp=2) in the Facetgrid. The final plot has has two enhancements — 1) the veritcal line for the y-axis is removed and 2) the tick marks removed from both the axis and major grid lines shown for y-axis.\n\nsns.set_theme(style=\"white\", font_scale=1.25)\np2 = sns.catplot(data=iris_melt, x=\"Class\", y=\"value\", kind=\"swarm\", size=3,\n                 col=\"Feature\", height=4, aspect=1.5, col_wrap=2, hue=\"Class\", errorbar=None)\np2.despine(left=True)\nfor ax in p2.axes.flat:\n    ax.tick_params(axis='both', which='both', length=0)\n    ax.yaxis.grid(True)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "14  Functions",
    "section": "",
    "text": "14.1 Arguments\nIn programming when a sub-set of code is to be execute in one go, we have an option to give a name to that sub-set and that name is now a function. As an analogy consider the steps in making tea.\nThe above steps need to be done every time we make tea. Also, we can create a new sub-set with some customization — “Make Tea with options”. So, whenever we say “make tea” it is implied that the step mentioned above would be performed and we don’t need to mention the steps again; just make tea is enough. Similarly, in programming, we can assign a keyword to a code block such that every time that keyword is called all the code within that block gets executed. Continuing with our analogy, we now have two “functions” – “Make Tea” and “Make Tea with options”.\nSo far we have used various in-built Python functions. Now let’s look at how we can define our own functions to do a specific task. To define a function, def keyword is used followed by a function name and parenthesis. The def statement ends with a colon and the statement within the function are indented (a syntax similar to for and if statements). A function can be initialized with or without arguments. To call a function, specify the function name along with the parenthesis. Below is a “Hello world!” function.\nThe argument(s) that a function takes goes inside the parenthesis when defining the function. An argument can be positional i.e. it must be specified in a particular sequence or it can be a keyword argument (these can be specified in any order). An important point to note about functions is that the variables within a function have a local scope i.e. a variable declared within a function cannot be accessed outside the function. So, let’s say we have a function that does some calculation and we would like to get the result of that calculation. In such cases, we need to return the variable(s) using the return keyword. When calling the function these returned values are assigned to specified variables. Below is an example of a function with two positional arguments. Notice that when calling this function the order of argument is important.\ndef calcPower(a,b):\n    c = a**b\n    return c\noutput_1 = calcPower(3,4)\nprint(output_1)\noutput_2 = calPower(4,3)\nprint(output_2)\n\n81\n64",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#keyword-arguments",
    "href": "Functions.html#keyword-arguments",
    "title": "14  Functions",
    "section": "14.2 Keyword arguments",
    "text": "14.2 Keyword arguments\nWe can have the same function with keyword arguments such that now the arguments can be specified in any order. All keyword arguments need to have a default value. If a value for a keyword argument is not specified while calling the function, the default value of the keyword is used.\n\ndef calcPower(number=1,power=1):\n    c = number**power\n    return c\noutput_1 = calcPower(power=3,number=4)\nprint(output_1)\n\n64\n\n\nIt is important to note here that keyword arguments can be specified without keywords as well when calling a function. In this case, the order of arguments passed would be matched to the order of the keywords in the function definition.\n\ncalcPower(2,3)\n\n8",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#variable-number-of-arguments",
    "href": "Functions.html#variable-number-of-arguments",
    "title": "14  Functions",
    "section": "14.3 Variable number of arguments",
    "text": "14.3 Variable number of arguments\nA function can have both positional and keyword arguments and in such case, the keyword arguments must be specified after positional arguments.\nIt is also possible to have an arbitrary number of positional and keyword arguments. The *args argument maintains a tuple named args that stores all the arguments passed when a function is called.\n\ndef sumNums(*args):\n    '''This function would add any set of numbers.\n    It has been defined using *args.'''\n    c = 0\n    for num in args:\n        c = c+num\n    return c\nprint(sumNums(4,5,6))\n\n15\n\n\nThe tripple quoted string in the above function not only acts a comment but is also available as help for this function accessible via help function.\n\nhelp(sumNums)\n\nHelp on function sumNums in module __main__:\n\nsumNums(*args)\n    This function would add any set of numbers.\n    It has been defined using *args.\n\n\n\n Quiz: Write a function to calculate (a + b)2. \n\n\nShow answer\ndef squareSum(a,b):\n    c = a**2 + b**2 + 2*a*b\n    return c\nnum1 = 4\nnum2 = 5\nprint(f\"The square of sum of {num1} and {num2} is {squareSum(num1,num2)}.\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#variable-number-of-keyword-arguments",
    "href": "Functions.html#variable-number-of-keyword-arguments",
    "title": "14  Functions",
    "section": "14.4 Variable number of keyword arguments",
    "text": "14.4 Variable number of keyword arguments\nThe **kwargs argument is used to have an arbitrary number of keyword arguments. Note the two asterisks. In this case, a kwargs dictionary is maintained which as the keyword and its value as key-value pairs of the dictionary.\n\ndef func1(**kwargs):\n    all_keywords = kwargs.keys()\n    all_values = kwargs.values()\n    return all_keywords, all_values\nk1,v1 = func1(name=\"Sam\", age=20)\nprint(k1)\nprint(v1)\n\ndict_keys(['name', 'age'])\ndict_values(['Sam', 20])",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#reusing-functions",
    "href": "Functions.html#reusing-functions",
    "title": "14  Functions",
    "section": "14.5 Reusing functions",
    "text": "14.5 Reusing functions\nFunction is a python file can be accessed in another python code. E.g., we have a file fileA.py that has function funcInFileA. Now to call this function from FileB.py we need to import this function — from fileA import funcInFileA.\n\n\n\n\n\n\nRecommendation\n\n\n\nTo practice function import it is advisable to do it on a console rather than inside notebook.\n\n\n\n# fileA.py\ndef funcInFileA():\n    print(\"Inside File A\")\n\n\n#fileB.py\nfrom fileA import funcInFileA\nfuncInFileA()\n\nInside File A\n\n\nSave the above two files in the same folder and then execute fileB.py. If we execute file fileA.py then there would be no output since we are not calling the function funcInFileA in that file. In case we do call funcInFileA in fileA.py then this function would be called twice upon calling from fileB.py.\nIf you would like to have an option to call funcInFileA from both the files and prevent calling it twice when importing this function then you need to use a special variable called __name__ (note the two underscores at the beginning and the end). This variable stores the name of the module which is being executed. Each python file or a module has a __name__ variable associated with it. When a python file is executed this variable is assigned a value __main__.\n\nprint(__name__)\n\n__main__\n\n\nHere the value is __main__ because we are executing the code directly. When we import a function then the value of the __name__ variable is set to the filename in which we have the imported function. So the recommended way to call funcInFileA would be to first check the value of __name__ followed by conditional calling. At the end of fileA.py, we can the following code.\n\n#Add this to fileA.py\nif __name__ == \"__main__\":\n    funcInFileA()\n\nNow, the function is called when we execute either of the files. Upon executing fileB.py, since the function is imported, the __name__ variable for fileA would not be equal to __main__ and hence would not be called because the if condition there would be false.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html",
    "href": "BioPython_Intro.html",
    "title": "15  Introduction to BioPython",
    "section": "",
    "text": "15.1 Sequence Object\nPython offers a variety of functions to work with text data (Strings) that in turn make it easier to work with biological data such as DNA or protein sequences. BioPython library provides a set of classes dedicated to parsing and analysis of different type of biological data. The functions avaiable in BioPython helps researcher to progammatically process the data. Below we’ll see some of the features in Biopython for working with biological data.\nTo install Biopython library run pip install biopython. For more details regarding Biopython installation and tutorials, please refer to the Biopython wiki.\nTo check the version of Biopython, run the following command.\nTo work with sequences, we’ll need the Bio.Seq class which has the required functions for reading and writing sequence data. Once we have imported this class we can create objects having required data. The example below shows constructing a sequence object with a DNA sequence and then using the complement and translate functions to find the sequence of the complementary strand and the translated protein sequence, respectively.\nfrom Bio.Seq import Seq\nnew_sequence = Seq('AATTGGAACCTT')\nprint(new_sequence)\nprint(new_sequence.complement())\nprint(new_sequence.translate())\n\nAATTGGAACCTT\nTTAACCTTGGAA\nNWNL\nLooking at the sequence object, one might wonder how is this different from a string object. Because we can easily initialize a string variable with the required sequence as the value. The difference here is that the two are the objects of different classes i.e. the Seq object belongs to the Bio.Seq.Seq class whereas the string object belongs to Str. These differences in turn indicate the differences in the kind of functionality associated with these objects (think object-oriented programming). For example, the complement and translate functions make sense only in the case of sequences and not in the case of any generic text.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#the-sequtils-package",
    "href": "BioPython_Intro.html#the-sequtils-package",
    "title": "15  Introduction to BioPython",
    "section": "15.2 The SeqUtils package",
    "text": "15.2 The SeqUtils package\nThe Bio.SeqUtils package offers a set of utility functions for getting some basic information about the sequences. These include, e.g., calculating the GC content or the melting temperature for the DNA sequences.\n\nfrom Bio.SeqUtils import gc_fraction\nfrom Bio.SeqUtils import MeltingTemp as mt\nprint(gc_fraction(new_sequence))\nprint(mt.Tm_Wallace(new_sequence)) # Tm_GC can also be used.\n\n0.3333333333333333\n32.0\n\n\nSimilarly, there are functions to get information about the protein sequences. The ProtParam module has utility functions for performing basic analysis of protein sequences. For example, the molecular_weight function returns the molecular weight of the protein and the count_amino_acids function returns a dictionary having the count for all the amino acids.\n\nfrom Bio.SeqUtils.ProtParam import ProteinAnalysis\nP1 = ProteinAnalysis(\"MFAEGRNREST\")\nprint(P1.molecular_weight())\nprint(P1.count_amino_acids()) # get_amino_acid_percent can also be used.\n\n1297.3975\n{'A': 1, 'C': 0, 'D': 0, 'E': 2, 'F': 1, 'G': 1, 'H': 0, 'I': 0, 'K': 0, 'L': 0, 'M': 1, 'N': 1, 'P': 0, 'Q': 0, 'R': 2, 'S': 1, 'T': 1, 'V': 0, 'W': 0, 'Y': 0}",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#reading-and-writing-sequences",
    "href": "BioPython_Intro.html#reading-and-writing-sequences",
    "title": "15  Introduction to BioPython",
    "section": "15.3 Reading and writing sequences",
    "text": "15.3 Reading and writing sequences\nWhen we are working with the sequence data, we generally do not type sequences instead we read (and write) sequences from a file. We’ll now see how to read and write sequences using BioPython.\nTo create a sequence object by reading sequence from a file, we can use the SeqIO class. The parse function in this class can read and write sequences in different formats. This function take two arguments - file name and format, and return an iterator having all the sequences. The code below shows reading a file having multiple sequences and printing the sequences using the seq attribute. Note that this would print sequnces without any annotations. The description attribute of SeqIO object can used to print the description of a sequence as given in the input file. In the code below, the output would be restricted to first three sequences. If you need to print the data for all sequences then remove the if block. The sequence file used in the example below is available here\n\nfrom Bio import SeqIO\ncount=0\nfor all_seqs in SeqIO.parse(\"Human_MAPK.fasta\", \"fasta\"):\n    print(all_seqs.description)\n    print(all_seqs.seq)\n    count += 1\n    if(count == 3):\n        break\n\nsp|O15264|MK13_HUMAN Mitogen-activated protein kinase 13 OS=Homo sapiens OX=9606 GN=MAPK13 PE=1 SV=1\nMSLIRKKGFYKQDVNKTAWELPKTYVSPTHVGSGAYGSVCSAIDKRSGEKVAIKKLSRPFQSEIFAKRAYRELLLLKHMQHENVIGLLDVFTPASSLRNFYDFYLVMPFMQTDLQKIMGMEFSEEKIQYLVYQMLKGLKYIHSAGVVHRDLKPGNLAVNEDCELKILDFGLARHADAEMTGYVVTRWYRAPEVILSWMHYNQTVDIWSVGCIMAEMLTGKTLFKGKDYLDQLTQILKVTGVPGTEFVQKLNDKAAKSYIQSLPQTPRKDFTQLFPRASPQAADLLEKMLELDVDKRLTAAQALTHPFFEPFRDPEEETEAQQPFDDSLEHEKLTVDEWKQHIYKEIVNFSPIARKDSRRRSGMKL\nsp|O60271|JIP4_HUMAN C-Jun-amino-terminal kinase-interacting protein 4 OS=Homo sapiens OX=9606 GN=SPAG9 PE=1 SV=4\nMELEDGVVYQEEPGGSGAVMSERVSGLAGSIYREFERLIGRYDEEVVKELMPLVVAVLENLDSVFAQDQEHQVELELLRDDNEQLITQYEREKALRKHAEEKFIEFEDSQEQEKKDLQTRVESLESQTRQLELKAKNYADQISRLEEREAELKKEYNALHQRHTEMIHNYMEHLERTKLHQLSGSDQLESTAHSRIRKERPISLGIFPLPAGDGLLTPDAQKGGETPGSEQWKFQELSQPRSHTSLKVSNSPEPQKAVEQEDELSDVSQGGSKATTPASTANSDVATIPTDTPLKEENEGFVKVTDAPNKSEISKHIEVQVAQETRNVSTGSAENEEKSEVQAIIESTPELDMDKDLSGYKGSSTPTKGIENKAFDRNTESLFEELSSAGSGLIGDVDEGADLLGMGREVENLILENTQLLETKNALNIVKNDLIAKVDELTCEKDVLQGELEAVKQAKLKLEEKNRELEEELRKARAEAEDARQKAKDDDDSDIPTAQRKRFTRVEMARVLMERNQYKERLMELQEAVRWTEMIRASRENPAMQEKKRSSIWQFFSRLFSSSSNTTKKPEPPVNLKYNAPTSHVTPSVKKRSSTLSQLPGDKSKAFDFLSEETEASLASRREQKREQYRQVKAHVQKEDGRVQAFGWSLPQKYKQVTNGQGENKMKNLPVPVYLRPLDEKDTSMKLWCAVGVNLSGGKTRDGGSVVGASVFYKDVAGLDTEGSKQRSASQSSLDKLDQELKEQQKELKNQEELSSLVWICTSTHSATKVLIIDAVQPGNILDSFTVCNSHVLCIASVPGARETDYPAGEDLSESGQVDKASLCGSMTSNSSAETDSLLGGITVVGCSAEGVTGAATSPSTNGASPVMDKPPEMEAENSEVDENVPTAEEATEATEGNAGSAEDTVDISQTGVYTEHVFTDPLGVQIPEDLSPVYQSSNDSDAYKDQISVLPNEQDLVREEAQKMSSLLPTMWLGAQNGCLYVHSSVAQWRKCLHSIKLKDSILSIVHVKGIVLVALADGTLAIFHRGVDGQWDLSNYHLLDLGRPHHSIRCMTVVHDKVWCGYRNKIYVVQPKAMKIEKSFDAHPRKESQVRQLAWVGDGVWVSIRLDSTLRLYHAHTYQHLQDVDIEPYVSKMLGTGKLGFSFVRITALMVSCNRLWVGTGNGVIISIPLTETNKTSGVPGNRPGSVIRVYGDENSDKVTPGTFIPYCSMAHAQLCFHGHRDAVKFFVAVPGQVISPQSSSSGTDLTGDKAGPSAQEPGSQTPLKSMLVISGGEGYIDFRMGDEGGESELLGEDLPLEPSVTKAERSHLIVWQVMYGNE\nsp|O60336|MABP1_HUMAN Mitogen-activated protein kinase-binding protein 1 OS=Homo sapiens OX=9606 GN=MAPKBP1 PE=1 SV=4\nMAVEGSTITSRIKNLLRSPSIKLRRSKAGNRREDLSSKVTLEKVLGITVSGGRGLACDPRSGLVAYPAGCVVVLFNPRKHKQHHILNSSRKTITALAFSPDGKYLVTGESGHMPAVRVWDVAEHSQVAELQEHKYGVACVAFSPSAKYIVSVGYQHDMIVNVWAWKKNIVVASNKVSSRVTAVSFSEDCSYFVTAGNRHIKFWYLDDSKTSKVNATVPLLGRSGLLGELRNNLFTDVACGRGKKADSTFCITSSGLLCEFSDRRLLDKWVELRNIDSFTTTVAHCISVSQDYIFCGCADGTVRLFNPSNLHFLSTLPRPHALGTDIASVTEASRLFSGVANARYPDTIALTFDPTNQWLSCVYNDHSIYVWDVRDPKKVGKVYSALYHSSCVWSVEVYPEVKDSNQACLPPSSFITCSSDNTIRLWNTESSGVHGSTLHRNILSSDLIKIIYVDGNTQALLDTELPGGDKADASLLDPRVGIRSVCVSPNGQHLASGDRMGTLRVHELQSLSEMLKVEAHDSEILCLEYSKPDTGLKLLASASRDRLIHVLDAGREYSLQQTLDEHSSSITAVKFAASDGQVRMISCGADKSIYFRTAQKSGDGVQFTRTHHVVRKTTLYDMDVEPSWKYTAIGCQDRNIRIFNISSGKQKKLFKGSQGEDGTLIKVQTDPSGIYIATSCSDKNLSIFDFSSGECVATMFGHSEIVTGMKFSNDCKHLISVSGDSCIFVWRLSSEMTISMRQRLAELRQRQRGGKQQGPSSPQRASGPNRHQAPSMLSPGPALSSDSDKEGEDEGTEEELPALPVLAKSTKKALASVPSPALPRSLSHWEMSRAQESVGFLDPAPAANPGPRRRGRWVQPGVELSVRSMLDLRQLETLAPSLQDPSQDSLAIIPSGPRKHGQEALETSLTSQNEKPPRPQASQPCSYPHIIRLLSQEEGVFAQDLEPAPIEDGIVYPEPSDNPTMDTSEFQVQAPARGTLGRVYPGSRSSEKHSPDSACSVDYSSSCLSSPEHPTEDSESTEPLSVDGISSDLEEPAEGDEEEEEEEGGMGPYGLQEGSPQTPDQEQFLKQHFETLASGAAPGAPVQVPERSESRSISSRFLLQVQTRPLREPSPSSSSLALMSRPAQVPQASGEQPRGNGANPPGAPPEVEPSSGNPSPQQAASVLLPRCRLNPDSSWAPKRVATASPFSGLQKAQSVHSLVPQERHEASLQAPSPGALLSREIEAQDGLGSLPPADGRPSRPHSYQNPTTSSMAKISRSISVGENLGLVAEPQAHAPIRVSPLSKLALPSRAHLVLDIPKPLPDRPTLAAFSPVTKGRAPGEAEKPGFPVGLGKAHSTTERWACLGEGTTPKPRTECQAHPGPSSPCAQQLPVSSLFQGPENLQPPPPEKTPNPMECTKPGAALSQDSEPAVSLEQCEQLVAELRGSVRQAVRLYHSVAGCKMPSAEQSRIAQLLRDTFSSVRQELEAVAGAVLSSPGSSPGAVGAEQTQALLEQYSELLLRAVERRMERKL\n\n\n\n15.3.1 Writing sequences\nThe write function takes three arguments — 1) a sequence object, 2) filename, and 3) file format. The code below reads a fasta file with multiple sequences and then save the first 10 sequences in a new file.\n\nall_seqs = []\nfor seq_record in SeqIO.parse(\"Human_MAPK.fasta\", \"fasta\"):\n    all_seqs.append(seq_record)\nprint(len(all_seqs))\n\nSeqIO.write(all_seqs[0:5],\"first_5.fasta\",\"fasta\")\n\n27\n\n\n5",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#multiple-sequence-alignment",
    "href": "BioPython_Intro.html#multiple-sequence-alignment",
    "title": "15  Introduction to BioPython",
    "section": "15.4 Multiple Sequence Alignment",
    "text": "15.4 Multiple Sequence Alignment\nThe AlignIO class has functions to parse alignment files. The read and write functions have a similar syntax to the corresponding functions in the SeqIO class. The alignment object stores sequences in 2D array format such that the rows are number of sequences and columns represent alignment length. To extract a sub-set of an alignment, slicing feature can be used. The code below shows reading an alignment file in fasta format followed by selecting a portion of this alignment and save it in a new file in clustal format. The subset is extracted by giving the range for the rows and columns within square brackets. The numbering for both rows and columns starts from zero. In the example below first ten sequences in the alignment are selected since range of rows is :10 and the colums range is 3:12. The sequence file used in the code below is available here.\n\nfrom Bio import AlignIO\nalign1 = AlignIO.read(\"kinases.txt\", \"fasta\")\n\n# slicing - [row range, col range]\nx = align1[:10,3:12]\nprint(x)\nAlignIO.write(x,\"msa1.aln\",\"clustal\")\n\nAlignment with 10 rows and 9 columns\nLKVL-GKGA consensus\nIKEL-GRGN sp|Q22RR1||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|Q234E6||agc:agc-sar|Tetrahymena\nVKKL-GNGQ sp|Q23KG5||agc:agc-sar|Tetrahymena\nIKTL-AFGQ sp|Q23DN8||agc:agc-sar|Tetrahymena\nIKKL-GVGQ sp|I7MFS4||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7M3B5||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7MD55||agc:agc-sar|Tetrahymena\nIKKL-GEGQ sp|Q869J9|pkg-2|agc:pkg|Paramecium\nIRVL-GKGC sp|A8N3F0||agc:agc-unique|Coprinopsis\n\n\n1\n\n\n\n# %load msa1.aln\nCLUSTAL X (1.81) multiple sequence alignment\n\n\nconsensus                           LKVL-GKGA\nsp|Q22RR1||agc:agc-sar|Tetrahy      IKEL-GRGN\nsp|Q234E6||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q23KG5||agc:agc-sar|Tetrahy      VKKL-GNGQ\nsp|Q23DN8||agc:agc-sar|Tetrahy      IKTL-AFGQ\nsp|I7MFS4||agc:agc-sar|Tetrahy      IKKL-GVGQ\nsp|I7M3B5||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|I7MD55||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q869J9|pkg-2|agc:pkg|Parame      IKKL-GEGQ\nsp|A8N3F0||agc:agc-unique|Copr      IRVL-GKGC",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#accessing-databases-using-api",
    "href": "BioPython_Intro.html#accessing-databases-using-api",
    "title": "15  Introduction to BioPython",
    "section": "15.5 Accessing databases using API",
    "text": "15.5 Accessing databases using API\n\nfrom Bio import Entrez, SeqIO\nEntrez.email = \"you@example.com\"\nhandle1 = Entrez.efetch(db=\"nucleotide\", id=\"NM_001301717\", rettype=\"gb\", retmode=\"text\")\nrecord1 = SeqIO.read(handle1, \"genbank\")\n\n\nprint(record1.description)\nprint(len(record1.seq))\nprint(record1.seq[:50]) \n\nHomo sapiens C-C motif chemokine receptor 7 (CCR7), transcript variant 4, mRNA\n2191\nCTCTAGATGAGTCAGTGGAGGGCGGGTGGAGCGTTGAACCGTGAAGAGTG\n\n\nTo retrieve multiple sequence, pass a comma-separated ids to the id keyword parameter. This time we’ll need to use the parse function to get the sequences from the efetch output.\n\nall_ids = [\"NP_000240.1\", \"NP_000549.1\", \"NP_001289656.1\"]\nhandle2 = Entrez.efetch(db=\"protein\", id=\",\".join(all_ids), rettype=\"gb\", retmode=\"text\")\nrecord2 = list(SeqIO.parse(handle2, \"genbank\"))\n\n\nprint(f\"There are {len(record2)} sequences\")\nfor record in record2:\n    print(record.description)\n    print(len(record.seq))\n\nThere are 3 sequences\nDNA mismatch repair protein Mlh1 isoform 1 [Homo sapiens]\n756\nhemoglobin subunit alpha [Homo sapiens]\n142\nfloral homeotic protein GLOBOSA-like [Eucalyptus grandis]\n208",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#accessing-databases-without-api",
    "href": "BioPython_Intro.html#accessing-databases-without-api",
    "title": "15  Introduction to BioPython",
    "section": "15.6 Accessing databases without API",
    "text": "15.6 Accessing databases without API\n\nimport requests\n\nuniprot_id = \"P12345\"  # Replace with the protein UniProt ID\nurl = f\"https://www.uniprot.org/uniprot/{uniprot_id}.fasta\"\n\nresponse = requests.get(url)\nprint(response.text)\n\n&gt;sp|P12345|AATM_RABIT Aspartate aminotransferase, mitochondrial OS=Oryctolagus cuniculus OX=9986 GN=GOT2 PE=1 SV=2\nMALLHSARVLSGVASAFHPGLAAAASARASSWWAHVEMGPPDPILGVTEAYKRDTNSKKM\nNLGVGAYRDDNGKPYVLPSVRKAEAQIAAKGLDKEYLPIGGLAEFCRASAELALGENSEV\nVKSGRFVTVQTISGTGALRIGASFLQRFFKFSRDVFLPKPSWGNHTPIFRDAGMQLQSYR\nYYDPKTCGFDFTGALEDISKIPEQSVLLLHACAHNPTGVDPRPEQWKEIATVVKKRNLFA\nFFDMAYQGFASGDGDKDAWAVRHFIEQGINVCLCQSYAKNMGLYGERVGAFTVICKDADE\nAKRVESQLKILIRPMYSNPPIHGARIASTILTSPDLRKQWLQEVKGMADRIIGMRTQLVS\nNLKKEGSTHSWQHITDQIGMFCFTGLKPEQVERLTKEFSIYMTKDGRISVAGVTSGNVGY\nLAHAIHQVTK\n\n\n\nTo get multiple sequences from Uniprot use the bulk query format\n\nuniprot_ids = [\"P69905\", \"P68871\"] \n\nquery = \" OR \".join([f\"accession:{uid}\" for uid in uniprot_ids])\nurl = f\"https://rest.uniprot.org/uniprotkb/stream?format=fasta&query={query}\"\n\nresponse = requests.get(url)\nresponse.raise_for_status()  # Raise an error for failed requests\n\n\nfrom io import StringIO\nfasta_io = StringIO(response.text)\nrecords = list(SeqIO.parse(fasta_io, \"fasta\"))\n\n\nfor record in records:\n    print(record.description)\n    print(len(record.seq))\n\nsp|P68871|HBB_HUMAN Hemoglobin subunit beta OS=Homo sapiens OX=9606 GN=HBB PE=1 SV=2\n147\nsp|P69905|HBA_HUMAN Hemoglobin subunit alpha OS=Homo sapiens OX=9606 GN=HBA1 PE=1 SV=2\n142",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#running-blast-over-the-internet",
    "href": "BioPython_Intro.html#running-blast-over-the-internet",
    "title": "15  Introduction to BioPython",
    "section": "15.7 Running BLAST over the internet",
    "text": "15.7 Running BLAST over the internet\nBiopython offers a functionality to programmatically run BLAST on the NCBI servers using the Bio.Blast class. To run blast online at NCBI servers, Bio.Blast can be used which has different function to run Blast and also to parse the output. The NCBIWWW library has qblast function that takes three arguments &emdash; 1) blast program (blastp, blastn, etc.), 2) database (any of the databases available at NCBI, and 3) sequence. Once the blast serach is over the output can be saved in a file. This output would be in XML format. We can use the read function within the NCBIXML class to parse this output. The code below shows running a blast search using qblast against the non-redundant database available at in NCBI. The output file saved in the previous step has all the hits identified in the Blast search. These hits follow a hierarchical manner such that each result would have multiple alignments and within each alignment would be multiple high scoring pairs (hsps) i.e. Blast object \\(\\longrightarrow\\) Alignment \\(\\longrightarrow\\) hsps. For more details on this you may refer to the Blast documentation available at NCBI.\n\nfrom Bio.Blast import NCBIWWW\nfrom Bio.Blast import NCBIXML\n\nresult_ncbi = NCBIWWW.qblast(\"blastn\", \"nt\", \"8332116\")\n\nwith open(\"my_blast.xml\", \"w\") as file_handle:\n    file_handle.write(result_ncbi.read())\n\n\nresult_handle = open(\"my_blast.xml\")\nblast_record = NCBIXML.read(result_handle)\ncount = 0\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        print(hsp)\n    count += 1\n    if(count==5):\n        break\n\nScore 482 (435 bits), expectation 5.6e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 463 (418 bits), expectation 1.5e-111, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      42 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 631\nScore 443 (400 bits), expectation 4.0e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nScore 441 (398 bits), expectation 1.4e-105, alignment length 593\nQuery:      65 AATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATT...CTG 655\n               ||||||||| |||  | |  | |||||||||||||||||||    ... ||\nSbjct:     254 AATGGGGAG-GAA--GGATAATTTGGCCATGAAAACTGATCC---...ATG 838\nScore 439 (397 bits), expectation 4.9e-105, alignment length 596\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CTG 655\n               |||||||||||    ||| |||  ||||| |||| |||||||| |...|||\nSbjct:     169 AAAATGGGGAGG---ATGGAGTTTTTGGCTATGAGAACTGATCCA...CTG 755\n\n\nThe hsps object has several attributes including the BLAST statistics such as evalue, score, positives, etc. These can be used to extract hits based on certain conditions. E.g., the code below shows saving hits from the previous Blast search with evalue greater than 1e-105 to a new file.\n\nwith open(\"new_file.txt\", \"w\") as file_handle:\n    for alignment in blast_record.alignments:\n        for hsp in alignment.hsps:\n            if (hsp.expect &lt; 1e-105):\n                print(hsp)\n                file_handle.write(str(hsp)+\"\\n\")\n                file_handle.write(\"\\n\")\nprint(\"DONE\")\n\nScore 482 (435 bits), expectation 5.6e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 463 (418 bits), expectation 1.5e-111, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      42 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 631\nScore 443 (400 bits), expectation 4.0e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nDONE",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#creating-a-dataframe-of-blast-results",
    "href": "BioPython_Intro.html#creating-a-dataframe-of-blast-results",
    "title": "15  Introduction to BioPython",
    "section": "15.8 Creating a dataframe of BLAST results",
    "text": "15.8 Creating a dataframe of BLAST results\nThe better approach to work with BLAST results is to create a dataframe having all the attributes for all the hits. The following code iterates through the BLAST output and creates a pandas dataframe having all the results.\n\nimport pandas as pd\n\nresult_handle = open(\"my_blast.xml\")\nblast_record = NCBIXML.read(result_handle)\nblast_data = []\n\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        # append a dictionary of attributes for each hit\n        blast_data.append({\n        \"query_id\": blast_record.query_id,\n            \"hit_id\": alignment.hit_id,\n            \"hit_def\": alignment.hit_def,\n            \"accession\": alignment.accession,\n            \"hit_length\": alignment.length,\n\n            \"e_value\": hsp.expect,\n            \"bit_score\": hsp.bits,\n            \"score\": hsp.score,\n            \"alignment_length\": hsp.align_length,\n            \"identity\": hsp.identities,\n            \"positives\": hsp.positives,\n            \"gaps\": hsp.gaps,\n            \"percent_identity\": 100 * hsp.identities / hsp.align_length,\n            \"percent_positives\": 100 * hsp.positives / hsp.align_length,\n\n            \"query_start\": hsp.query_start,\n            \"query_end\": hsp.query_end,\n            \"subject_start\": hsp.sbjct_start,\n            \"subject_end\": hsp.sbjct_end,\n            \n            \"query_sequence\": hsp.query,\n            \"match_sequence\": hsp.match,\n            \"subject_sequence\": hsp.sbjct,\n        })\n\n# Create DataFrame\ndf = pd.DataFrame(blast_data)\n\nprint(df.shape)\ndf.head()\n\n(50, 23)\n\n\n\n\n\n  \n    \n      \n      query_id\n      hit_id\n      hit_def\n      accession\n      hit_length\n      e_value\n      bit_score\n      score\n      alignment_length\n      identity\n      ...\n      percent_positives\n      query_start\n      query_end\n      subject_start\n      subject_end\n      query_frame\n      strand\n      query_sequence\n      match_sequence\n      subject_sequence\n    \n  \n  \n    \n      0\n      BE037100.1\n      gi|1219041180|ref|XM_021875076.1|\n      PREDICTED: Chenopodium quinoa cold-regulated 4...\n      XM_021875076\n      1173\n      5.569490e-117\n      435.898\n      482.0\n      624\n      473\n      ...\n      75.801282\n      59\n      678\n      278\n      901\n      None\n      (Plus, Plus)\n      ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGAT...\n      || ||||||||| |||| | |||| ||  |||| |||| | |||| ...\n      ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGAG...\n    \n    \n      1\n      BE037100.1\n      gi|2514617377|ref|XM_021992092.2|\n      PREDICTED: Spinacia oleracea cold-regulated 41...\n      XM_021992092\n      752\n      1.494500e-111\n      418.766\n      463.0\n      590\n      447\n      ...\n      75.762712\n      63\n      649\n      42\n      631\n      None\n      (Plus, Plus)\n      AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAAT...\n      |||||||| |||  |||| | || ||||| |||||||| || ||||...\n      AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAAT...\n    \n    \n      2\n      BE037100.1\n      gi|2518612504|ref|XM_010682658.3|\n      PREDICTED: Beta vulgaris subsp. vulgaris cold-...\n      XM_010682658\n      621\n      4.010310e-106\n      400.732\n      443.0\n      597\n      448\n      ...\n      75.041876\n      87\n      679\n      25\n      621\n      None\n      (Plus, Plus)\n      TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGATT...\n      ||||||||||||||||| ||| ||||  |||||||| |||| ||||...\n      TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGATT...\n    \n    \n      3\n      BE037100.1\n      gi|2031543140|ref|XM_041168865.1|\n      PREDICTED: Juglans microcarpa x Juglans regia ...\n      XM_041168865\n      1020\n      1.399730e-105\n      398.929\n      441.0\n      593\n      448\n      ...\n      75.548061\n      65\n      655\n      254\n      838\n      None\n      (Plus, Plus)\n      AATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATTG...\n      ||||||||| |||  | |  | |||||||||||||||||||    |...\n      AATGGGGAG-GAA--GGATAATTTGGCCATGAAAACTGATCC---G...\n    \n    \n      4\n      BE037100.1\n      gi|2618480339|ref|XM_048479995.2|\n      PREDICTED: Ziziphus jujuba cold-regulated 413 ...\n      XM_048479995\n      1028\n      4.885550e-105\n      397.126\n      439.0\n      596\n      448\n      ...\n      75.167785\n      63\n      655\n      169\n      755\n      None\n      (Plus, Plus)\n      AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAAT...\n      |||||||||||    ||| |||  ||||| |||| |||||||| | ...\n      AAAATGGGGAGG---ATGGAGTTTTTGGCTATGAGAACTGATCCA-...\n    \n  \n\n5 rows × 23 columns\n\n\n\n\ndf.columns\n\nIndex(['query_id', 'hit_id', 'hit_def', 'accession', 'hit_length', 'e_value',\n       'bit_score', 'score', 'alignment_length', 'identity', 'positives',\n       'gaps', 'percent_identity', 'percent_positives', 'query_start',\n       'query_end', 'subject_start', 'subject_end', 'query_frame', 'strand',\n       'query_sequence', 'match_sequence', 'subject_sequence'],\n      dtype='object')\n\n\nNow that we have a dataframe, we can easily select hits based on desired thresholds. For instance, the code below selects all the hits with evalue less than 1e-105.\n\ndf[df[\"e_value\"] &lt; 1e-105]\n\n\n\n\n  \n    \n      \n      query_id\n      hit_id\n      hit_def\n      e_value\n      bit_score\n      score\n      query_start\n      query_end\n      subject_start\n      subject_end\n      alignment_length\n      identity\n      gaps\n      query_sequence\n      match_sequence\n      subject_sequence\n    \n  \n  \n    \n      0\n      BE037100.1\n      gi|1219041180|ref|XM_021875076.1|\n      PREDICTED: Chenopodium quinoa cold-regulated 4...\n      5.569490e-117\n      435.898\n      482.0\n      59\n      678\n      278\n      901\n      624\n      473\n      4\n      ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGAT...\n      || ||||||||| |||| | |||| ||  |||| |||| | |||| ...\n      ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGAG...\n    \n    \n      1\n      BE037100.1\n      gi|2514617377|ref|XM_021992092.2|\n      PREDICTED: Spinacia oleracea cold-regulated 41...\n      1.494500e-111\n      418.766\n      463.0\n      63\n      649\n      42\n      631\n      590\n      447\n      3\n      AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAAT...\n      |||||||| |||  |||| | || ||||| |||||||| || ||||...\n      AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAAT...\n    \n    \n      2\n      BE037100.1\n      gi|2518612504|ref|XM_010682658.3|\n      PREDICTED: Beta vulgaris subsp. vulgaris cold-...\n      4.010310e-106\n      400.732\n      443.0\n      87\n      679\n      25\n      621\n      597\n      448\n      4\n      TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGATT...\n      ||||||||||||||||| ||| ||||  |||||||| |||| ||||...\n      TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGATT...\n    \n  \n\n\n\n\nTo save the filtered set of hits (or the entire output) to a csv file, we can use the to_csv function.\n\ndf_top_hits = df[df[\"e_value\"] &lt; 1e-105]\ndf_top_hits.to_csv(\"Blast_hits.csv\", index=False)\n\n\n# %load Blast_hits.csv\nquery_id,hit_id,hit_def,e_value,bit_score,score,query_start,query_end,subject_start,subject_end,alignment_length,identity,gaps,query_sequence,match_sequence,subject_sequence\nBE037100.1,gi|1219041180|ref|XM_021875076.1|,\"PREDICTED: Chenopodium quinoa cold-regulated 413 plasma membrane protein 2-like (LOC110697660), mRNA\",5.56949e-117,435.898,482.0,59,678,278,901,624,473,4,ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGATTCCGATATCAATGAGCTTAAAATGGCAACAATGAGGCTCATCAATGATGCTAGTATGCTCGGT--CATTACGGG-TTTGGCACTCATTTCCTCAAATGGCTCGCCTGCCTTGCGGCTATTTACTTGTTGATATTGGATCGAACAAACTGGAGAACCAACATGCTCACGTCACTTTTAGTCCCTTACATATTCCTCAGTCTTCCATCCGGGCCATTTCATCTGTTCAGAGGCGAGGTCGGGAAATGGATTGCCATCATTGCAGTCGTGTTAAGGCTGTTCTTCAACCGGCATTTCCCAGTTTGGCTGGAAATGCCTGGATCGTTGATACTCCTCCTGGTGGTGGCACCAGACTTCTTTACACACAAAGTGAAGGAGAGCTGGATCGGAATTGCAATTATGATAGCGATAGGGTGTCACCTGATGCAAGAACATATCAGAGCCACTGGTGGCTTTTGGAATTCCTTCACACAGAGCCACGGAACTTTTAACACAATTGGGCTTATCCTTCTACTGGCTTACCCTGTCT-GTTTATGGTCATCTTCATGATGTA,|| ||||||||| |||| | |||| ||  |||| |||| | |||| ||| | |||| ||| ||| ||||| | ||||| ||||||||||| || || |     ||||  |||||  ||||||||  ||  |||||   ||   | || ||||| |||||||| || | |||||| ||||  ||||| |||||||||||||||||  ||||||| ||||| |||||||||||||||||||| ||||| ||||| || |||||||||||||||||||| || || || ||| | ||  | || || ||||| ||||||||||||||  |  | || || ||| ||||||| |||||| |||| |  |||||||  ||| | || ||||| |||||  |||||||  |  ||||||| || ||||| ||  |  |||||||| | ||||| || ||||| ||| ||| |||| || ||   ||||||||| |  || |||||||||||||||| || |||||||| ||  | ||||| || || || ||||| |||| ||   | || ||||||||  | ||  || ||||||||||  | | ||  ||||| || |||||||| ||,ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGAGCAACTAGCCGCGGCCAATTTGATCAACTCCGACATCAATGAGCTCAAGATCGTTGTGATGACACTCATTCATGATGCTTCTAGACTCGGCGGCACCTCAGGATTTGGAACTCATTTTCTTAGATGGCTAGCCTCTCTTGCTGCTATTTACTTGTTGATCCTGGATCGCACAAATTGGAGAACCAACATGCTCACATCACTCTTAGTACCATACATATTCCTCAGTCTTCCTTCTGGCCCTTTTTACCTTCTTAGGGGTGAGGTTGGGAAATGGATTGCTTTTGTCGCGGTTGTGCTAAGGCTATTCTTCCACCGCCGCTTCCCAGAATGGTTAGAGATGCCAGGATCACTGATACTATTGTTGGTGGTAGCTCCAGAATTGCTAGCACACAAATTAAAGGATAGTTGGATGGGAGTTGTAATTCTGTTAATCATAGGGTGTTATTTGCTGCAAGAACATATCAGGGCAACTGGTGGTTTAAGAAATTCGTTTACTCAAAGCCATGGAATTTCCTATACGATTGGGCTGCTTCTCTTATTGGCTTACCCAATTTGGTCCATGGTTATTTTCATGATTTA\nBE037100.1,gi|2514617377|ref|XM_021992092.2|,\"PREDICTED: Spinacia oleracea cold-regulated 413 plasma membrane protein 2-like (LOC110787470), mRNA\",1.4945e-111,418.766,463.0,63,649,42,631,590,447,3,AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGATTCCGATATCAATGAGCTTAAAATGGCAACAATGAGGCTCATCAATGATGCTAGTATGCTCGG---TCATTACGGGTTTGGCACTCATTTCCTCAAATGGCTCGCCTGCCTTGCGGCTATTTACTTGTTGATATTGGATCGAACAAACTGGAGAACCAACATGCTCACGTCACTTTTAGTCCCTTACATATTCCTCAGTCTTCCATCCGGGCCATTTCATCTGTTCAGAGGCGAGGTCGGGAAATGGATTGCCATCATTGCAGTCGTGTTAAGGCTGTTCTTCAACCGGCATTTCCCAGTTTGGCTGGAAATGCCTGGATCGTTGATACTCCTCCTGGTGGTGGCACCAGACTTCTTTACACACAAAGTGAAGGAGAGCTGGATCGGAATTGCAATTATGATAGCGATAGGGTGTCACCTGATGCAAGAACATATCAGAGCCACTGGTGGCTTTTGGAATTCCTTCACACAGAGCCACGGAACTTTTAACACAATTGGGCTTATCCTTCTACTGGCTTACCC,|||||||| |||  |||| | || ||||| |||||||| || ||||| |||| ||| ||| ||||||||||||||||||| ||||| || || ||    |||  |||| |  ||||| ||| || ||||||   ||| |  || || || |||||||| ||| ||||||||||||   || | |||||||||||||| ||  | ||||||||| | ||||||| ||||||||| || ||||||||||| || ||||| ||||| ||||| ||||| || || ||||| || || ||||| ||||| ||||||||||||||  |  |  | || ||| ||||| | |||||| ||||   ||||||||  ||| |||||||||| | ||  ||||||||  |  ||||||| || |||||  |  || ||     | |||| ||||| ||||| ||| ||| | || || ||   ||||| ||| ||||  | ||||| ||||| || || |||||||| ||  ||||||| |||||||| || || || | ||  ||||||||||||||| | ||  |  ||||||||||,AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAATTAGCCGCGGCCAATTTGATCGATTCCGATATCAACGAGCTGAAGATCGCCGTGATGGCGCTCGTTCATGATACTACTACGCTCGGCGGTCAATCGGGATTCGGAACTCATTTTCTCCAATGGCTCGCCTCATTTTCTGCTATTTACTTGTTAATCCTTGATCGAACACATTGGAGAAGCAACATGCTTACTTCACTTTTAGTACCATACATTTTCCTAAGTCTCCCATCTGGCCCCTTTCACCTTTTAAGAGGTGAGGTTGGGAAATGGATTGCTTTTGTCTCGGTTGTGCTAAGGTTATTCTTCCACCGCAGTTTCCCAGAATGGTTGGAAATGCCAGTATGTTTGATACTATTATTGGTGGTAGCTCCAGAAATGCTTGCAATATCAATGAAAGAGAGTTGGATGGGAGTTGTAGTTGTGTTAATCATAGGATGTTACCTTCTACAAGAGCATATTAGGGCAACTGGTGGTTTAAGGAATTCTTTCACACAAAGACATGGGATTTCCAACACAATTGGGCTTCTTCTCTTGTTGGCTTACCC\nBE037100.1,gi|2518612504|ref|XM_010682658.3|,\"PREDICTED: Beta vulgaris subsp. vulgaris cold-regulated 413 plasma membrane protein 2 (LOC104895996), mRNA\",4.01031e-106,400.732,443.0,87,679,25,621,597,448,4,TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGATTCCGATATCAATGAGCTTAAAATGGCAACAATGAGGCTCATCAATGATGCTAGTATGCTC---GGTCATTACGGGTTTGGCACTCATTTCCTCAAATGGCTCGCCTGCCTTGCGGCTATTTACTTGTTGATATTGGATCGAACAAACTGGAGAACCAACATGCTCACGTCACTTTTAGTCCCTTACATATTCCTCAGTCTTCCATCCGGGCCATTTCATCTGTTCAGAGGCGAGGTCGGGAAATGGATTGCCATCATTGCAGTCGTGTTAAGGCTGTTCTTCAACCGGCATTTCCCAGTTTGGCTGGAAATGCCTGGATCGTTGATACTCCTCCTGGTGGTGGCACCAGACTTCTTTACACACAAAGTGAAGGAGAGCTGGATCGGAATTGCAATTATGATAGCGATAGGGTGTCACCTGATGCAAGAACATATCAGAGCCACTGGTGGCTTTTGGAATTCCTTCACACAGAGCCACGGAACTTTTAACACAATTGGGCTTATCCTTCTACTGGCTTACCCTGTCT-GTTTATGGTCATCTTCATGATGTAG,||||||||||||||||| ||| ||||  |||||||| |||| ||||  ||||| ||||| ||||| || ||    |    ||| ||  ||||||||  ||  |||   |||||    || || || |||||||| ||||||||||| || |   |||| |||||||| ||| ||||  ||||||||||||| |||||||| |||||||| || |||||||||||||||||||||||| |||| |||||  | ||    ||||| || || || ||||| || || || ||||||||  | || ||||| ||  | ||| | || ||| |||| |||||||||| |||| |||||||||| ||||  ||||||||  |  ||||||| || ||  | || ||| |  | | | |||||||   |||| | ||  ||| | || || ||   ||||||||| |  || | ||||| ||||| ||||| || |||||  |  ||||||||||||| || | ||| || | || ||| |||||||||||| |||||||| ||||||||||  | | ||  ||  |||| ||||||||||||,TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGATTATGATATGAATGAACTTAAGATCGCTTTGACATCGCTAATTCATGATGCTGCTAGACTCAATGGTCACGGAGGATTCGGAACTCATTTTCTCAAATGGCTTGCTTCATTTGCTGCTATTTATTTGCTGATCCTGGATCGAACAAATTGGAGAACAAACATGCTAACATCACTTTTAGTCCCTTACATATTCTTCAGCCTTCCCACAGGCATCTTTCACCTTTTAAGGGGCGAAGTTGGTAAGTGGATTGCTTTTATCGCAGTTGTACTGAGGTTATTTTTCCACCGCCATTTCCCAGATTGGTTGGAAATGCCAGGATGTTTGATACTGTTGTTGGTGGTCGCTCCCAATTTATTTGCTTATACAATGAAGGATGACTGGTTGGGGGTTGTAGTTTTGTTAATCATAGGGTGTTATTTGCTACAAGAGCATATAAGAGCGACGGGTGGTCTCAGGAATTCCTTCACTCAAACCCATGGTATTTCTAATACAATTGGGCTTCTCCTTCTATTGGCTTACCCCATTTGGTCGATATTCATATTCATGATGTAG",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#plotting-blast-result",
    "href": "BioPython_Intro.html#plotting-blast-result",
    "title": "15  Introduction to BioPython",
    "section": "15.9 Plotting BLAST result",
    "text": "15.9 Plotting BLAST result\n\nimport matplotlib.pyplot as plt\n\n# Define bins and corresponding NCBI BLAST-style colors\nbins = [0, 50, 70, 80, 90, 100, float('inf')]\ncolors = ['blue', 'cyan', 'green', 'darkorange', 'magenta', 'red']\n\n# Assign color based on percent identity\ndf['color'] = pd.cut(df['percent_identity'], bins=bins, labels=colors, right=True)\n\n# Plot per query\nfor query in df['query_id'].unique():\n    sub_df = df[df['query_id'] == query]\n\n    plt.figure(figsize=(12, 2 + len(sub_df) * 0.3))\n    query_length = sub_df['query_end'].max()\n    plt.hlines(y=0, xmin=1, xmax=query_length, colors='black', linewidth=2, label='Query')\n\n    for i, row in enumerate(sub_df.itertuples(), start=1):\n        plt.hlines(y=-i, xmin=row.query_start, xmax=row.query_end, colors=row.color, linewidth=3)\n        plt.text(-100, -i, f\"{row.hit_id}\", va='center', fontsize=8)\n\n    plt.title(f\"Alignment Coverage for Query: {query}\")\n    plt.xlabel(\"Query Position\")\n    plt.yticks([0] + [-i for i in range(1, len(sub_df)+1)], ['Query'] + ['']*len(sub_df))\n    plt.grid(True, axis='x', linestyle='--', alpha=0.3)\n    plt.gca().spines[['top', 'right', 'left']].set_visible(False)\n    plt.tight_layout()\n    plt.show()",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  },
  {
    "objectID": "BioPython_Intro.html#blast-search-using-sequence-file",
    "href": "BioPython_Intro.html#blast-search-using-sequence-file",
    "title": "15  Introduction to BioPython",
    "section": "15.10 BLAST search using sequence file",
    "text": "15.10 BLAST search using sequence file\nTo run the Blast search using a sequence file instead of gi number, we first need to create a seqeunce object and then pass it on to the qblast function as shown below. To run this code, save the protein sequence below in a new file example1.fasta.\nMFHPGMTSQPSTSNQMYYDPLYGAEQIVQCNPMDYHQANILCGMQYFNNSHNRYPLLPQMPPQFTNDHPY DFPNVPTISTLDEASSFNGFLIPSQPSSYNNNNISCVFTPTPCTSSQASSQPPPTPTVNPTPIPPNAGAV LTTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITAVTSNGKQPTGCVTIQRSL DGRLQVAGRKGVPHVVYARIWRWPKVSKNELVKLVQCQTSSDHPDNICINPYHYERVVSNRITSADQSLH VENSPMKSEYLGDAGVIDSCSDWPNTPPDNNFNGGFAPDQPQLVTPIISDIPIDLNQIYVPTPPQLLDNW CSIIYYELDTPIGETFKVSARDHGKVIVDGGMDPHGENEGRLCLGALSNVHRTEASEKARIHIGRGVELT AHADGNISITSNCKIFVRSGYLDYTHGSEYSSKAHRFTPNESSFTVFDIRWAYMQMLRRSRSSNEAVRAQ AAAVAGYAPMSVMPAIMPDSGVDRMRRDFCTIAISFVKAWGDVYQRKTIKETPCWIEVTLHRPLQILDQL LKNSSQFGSS\n\nseq_file = open('example1.fasta')\nresult_handle2 = NCBIWWW.qblast(\"blastp\", \"nr\", seq_file.read())\nseq_file.close()\n\nwith open(\"test_blast.xml\", \"w\") as out_handle:\n    out_handle.write(result_handle2.read())\n\nblast_output = open(\"test_blast.xml\")    \nblast_record = NCBIXML.read(blast_output)\nprint(blast_record.alignments[0])\n\nsp|P45897.1| RecName: Full=Dwarfin sma-4; AltName: Full=MAD protein homolog 3 [Caenorhabditis elegans] &gt;gb|AAA97605.1| SMA-4 [Caenorhabditis elegans]\n           Length = 570\n\n\n\nLet’s say we need only the alignment with the mouse sequence, then, to print first 50 characters of each alignment with the mouse sequence along with corresponding statistics, the following code can be used.\n\nfor alignment in blast_record.alignments:\n    if \"Mus musculus\" in alignment.title:\n        print(alignment.title)\n        for hsp in alignment.hsps:\n            print(hsp.query[0:50])\n            print(hsp.match[0:50])\n            print(hsp.sbjct[0:50])\n            print(hsp.positives, hsp.score, hsp.expect)\n\ngb|KAI2586911.1| SMAD family member 4 [Homo sapiens] &gt;gb|KAI4046350.1| SMAD family member 4 [Homo sapiens] &gt;gb|PNI70022.1| SMAD4 isoform 6 [Pan troglodytes] &gt;gb|PNJ43713.1| SMAD4 isoform 9 [Pongo abelii]\nTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITA\nT+ D+C  I H L C++QGGE   F ++AIESLVKKLK+K+ ELD+LITA\nTSNDACLSIVHSLMCHRQGGESETFAKRAIESLVKKLKEKKDELDSLITA\n274 795.0 8.00678e-96",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to BioPython</span>"
    ]
  }
]